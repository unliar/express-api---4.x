<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <title>Express 4.x - API 中文手册</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/dropit.css">
    <link rel="stylesheet" href="css/prism.css">
    <link href="css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//fonts.useso.com/css?family=Open+Sans:300,400,600,700&amp;amp;subset=latin,latin-ext">
    <script data-cfasync="false" src="js/jquery.min.js"></script>
    <script data-cfasync="false" src="js/app.js"></script>
    <script data-cfasync="false" src="js/retina.js"></script>
    <script data-cfasync="false" src="js/dropit.js"></script>
    <script data-cfasync="false" src="js/prism.js"></script>
    <script>
    </script>
</head>

<body>
    <section class="content">
        <header>
            <div id="mobile-menu">
                <div id="nav-button" class="fa fa-bars fa-2x button"></div>
            </div>
            <section id="logo"><a href="/" class="express">Express</a>
            </section>
            <div id="navbar">
                <ul id="navmenu">
                    <li><a href="/" id="home-menu">首页</a></li>
                    <li>
                        <ul id="getting-started-menu" class="menu">
                            <li><a href="http://www.expressjs.com.cn/starter/installing.html">入门</a>
                                <ul>
                                    <li>
                                        <a href="http://www.expressjs.com.cn/starter/installing.html">
                                    安装
                                  </a>
                                    </li>
                                    <li>
                                        <a href="http://www.expressjs.com.cn/starter/hello-world.html">
                                    Hello world
                                  </a>
                                    </li>
                                    <li>
                                        <a href="http://www.expressjs.com.cn/starter/generator.html">
                                  Express 应用生成器
                                </a>
                                    </li>
                                    <li>
                                        <a href="http://www.expressjs.com.cn/starter/basic-routing.html">
                                    基本路由
                                  </a>
                                    </li>
                                    <li>
                                        <a href="http://www.expressjs.com.cn/starter/static-files.html">
                                    静态文件
                                  </a>
                                    </li>
                                    <li>
                                        <a href="http://www.expressjs.com.cn/starter/faq.html">
                                    常见问题
                                  </a>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <ul id="guide-menu" class="menu">
                            <li><a href="/guide/routing.html">使用指南</a>
                                <ul>
                                    <li><a href="http://www.expressjs.com.cn/guide/routing.html">路由</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/guide/using-middleware.html">中间件</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/guide/using-template-engines.html">模板引擎</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/guide/error-handling.html">错误处理</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/guide/debugging.html">调试</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/guide/behind-proxies.html">为 Express 设置代理</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/guide/migrating-4.html">升级到 Express 4</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/guide/database-integration.html">数据库集成</a>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <ul id="application-menu" class="menu">
                            <li><a href="http://www.expressjs.com.cn/4x/api.html">API 中文手册</a>
                                <ul>
                                    <li><a href="http://www.expressjs.com.cn/4x/api.html">4.x 版本</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/3x/api.html">3.x 版本</a>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <ul id="advanced-topics-menu" class="menu">
                            <li><a href="http://www.expressjs.com.cn/advanced/developing-template-engines.html">进阶话题</a>
                                <ul>
                                    <li><a href="http://www.expressjs.com.cn/advanced/developing-template-engines.html">模板引擎</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/advanced/pm.html">进程管理器</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/advanced/security-updates.html">安全更新</a>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <ul id="resources-menu" class="menu">
                            <li><a href="http://www.expressjs.com.cn/resources/glossary.html">有用的资源</a>
                                <ul>
                                    <li><a href="http://www.expressjs.com.cn/resources/glossary.html">术语表</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/resources/middleware.html">中间件</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/resources/community.html">社区</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/resources/books-blogs.html">书籍与博客</a>
                                    </li>
                                    <li><a href="http://www.expressjs.com.cn/resources/applications.html">实例展示</a>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </div>
        </header>
        <ul id="menu">
            <li id="express-api"><a href="#express">express()</a>
                <ul id="express-menu">
                    <li><em>Methods</em></li>
                    <li id="express-static-middleware"><a href="#express.static">express.static()</a></li>
                </ul>
            </li>
            <li id="app-api"><a href="#app">Application</a>
                <ul id="app-menu">
                    <li><em>Properties</em>
                    </li>
                    <li><a href="#app.locals">app.locals</a>
                    </li>
                    <li><a href="#app.mountpath">app.mountpath</a>
                    </li>
                    <li><em>Events</em>
                    </li>
                    <li><a href="#app.onmount">mount</a>
                    </li>
                    <li><em>Methods</em>
                    </li>
                    <li><a href="#app.all">app.all()</a>
                    </li>
                    <li><a href="#app.delete.method">app.delete()</a>
                    </li>
                    <li><a href="#app.disable">app.disable()</a>
                    </li>
                    <li><a href="#app.disabled">app.disabled()</a>
                    </li>
                    <li><a href="#app.enable">app.enable()</a>
                    </li>
                    <li><a href="#app.enabled">app.enabled()</a>
                    </li>
                    <li><a href="#app.engine">app.engine()</a>
                    </li>
                    <li><a href="#app.get">app.get()</a>
                    </li>
                    <li><a href="#app.get.method">app.get()</a>
                    </li>
                    <li><a href="#app.listen">app.listen()</a>
                    </li>
                    <li><a href="#app.METHOD">app.METHOD()</a>
                    </li>
                    <li><a href="#app.param">app.param()</a>
                    </li>
                    <li><a href="#app.path">app.path()</a>
                    </li>
                    <li><a href="#app.post.method">app.post()</a>
                    </li>
                    <li><a href="#app.put.method">app.put()</a>
                    </li>
                    <li><a href="#app.render">app.render()</a>
                    </li>
                    <li><a href="#app.route">app.route()</a>
                    </li>
                    <li><a href="#app.set">app.set()</a>
                    </li>
                    <li><a href="#app.use">app.use()</a>
                    </li>
                </ul>
            </li>
            <li id="req-api"><a href="#req">Request</a>
                <ul id="req-menu">
                    <li><em>Properties</em>
                    </li>
                    <li><a href="#req.app">req.app</a>
                    </li>
                    <li><a href="#req.baseUrl">req.baseUrl</a>
                    </li>
                    <li><a href="#req.body">req.body</a>
                    </li>
                    <li><a href="#req.cookies">req.cookies</a>
                    </li>
                    <li><a href="#req.fresh">req.fresh</a>
                    </li>
                    <li><a href="#req.hostname">req.hostname</a>
                    </li>
                    <li><a href="#req.ip">req.ip</a>
                    </li>
                    <li><a href="#req.ips">req.ips</a>
                    </li>
                    <li><a href="#req.originalUrl">req.originalUrl</a>
                    </li>
                    <li><a href="#req.params">req.params</a>
                    </li>
                    <li><a href="#req.path">req.path</a>
                    </li>
                    <li><a href="#req.protocol">req.protocol</a>
                    </li>
                    <li><a href="#req.query">req.query</a>
                    </li>
                    <li><a href="#req.route">req.route</a>
                    </li>
                    <li><a href="#req.secure">req.secure</a>
                    </li>
                    <li><a href="#req.signedCookies">req.signedCookies</a>
                    </li>
                    <li><a href="#req.stale">req.stale</a>
                    </li>
                    <li><a href="#req.subdomains">req.subdomains</a>
                    </li>
                    <li><a href="#req.xhr">req.xhr</a>
                    </li>
                    <li><em>Methods</em>
                    </li>
                    <li><a href="#req.accepts">req.accepts()</a>
                    </li>
                    <li><a href="#req.acceptsCharsets">req.acceptsCharsets()</a>
                    </li>
                    <li><a href="#req.acceptsEncodings">req.acceptsEncodings()</a>
                    </li>
                    <li><a href="#req.acceptsLanguages">req.acceptsLanguages()</a>
                    </li>
                    <li><a href="#req.get">req.get()</a>
                    </li>
                    <li><a href="#req.is">req.is()</a>
                    </li>
                    <li><a href="#req.param">req.param()</a>
                    </li>
                </ul>
            </li>
            <li id="res-api"><a href="#res">Response</a>
                <ul id="res-menu">
                    <li><em>Properties</em>
                    </li>
                    <li><a href="#res.app">res.app      </a>
                    </li>
                    <li><a href="#res.headersSent">res.headersSent</a>
                    </li>
                    <li><a href="#res.locals">res.locals</a>
                    </li>
                    <li><em>Methods</em>
                    </li>
                    <li><a href="#res.append">res.append()</a>
                    </li>
                    <li><a href="#res.attachment">res.attachment()</a>
                    </li>
                    <li><a href="#res.cookie">res.cookie()</a>
                    </li>
                    <li><a href="#res.clearCookie">res.clearCookie()</a>
                    </li>
                    <li><a href="#res.download">res.download()</a>
                    </li>
                    <li><a href="#res.end">res.end()</a>
                    </li>
                    <li><a href="#res.format">res.format()</a>
                    </li>
                    <li><a href="#res.get">res.get()</a>
                    </li>
                    <li><a href="#res.json">res.json()</a>
                    </li>
                    <li><a href="#res.jsonp">res.jsonp()</a>
                    </li>
                    <li><a href="#res.links">res.links()</a>
                    </li>
                    <li><a href="#res.location">res.location()</a>
                    </li>
                    <li><a href="#res.redirect">res.redirect()</a>
                    </li>
                    <li><a href="#res.render">res.render()</a>
                    </li>
                    <li><a href="#res.send">res.send()</a>
                    </li>
                    <li><a href="#res.sendFile">res.sendFile()</a>
                    </li>
                    <li><a href="#res.sendStatus">res.sendStatus()</a>
                    </li>
                    <li><a href="#res.set">res.set()</a>
                    </li>
                    <li><a href="#res.status">res.status()</a>
                    </li>
                    <li><a href="#res.type">res.type()</a>
                    </li>
                    <li><a href="#res.vary">res.vary()</a>
                    </li>
                </ul>
            </li>
            <li id="router-api"><a href="#router">Router</a>
                <ul id="router-menu">
                    <li><a href="#router">Router()</a>
                    </li>
                    <li><em>Methods</em>
                    </li>
                    <li><a href="#router.all">router.all()</a>
                    </li>
                    <li><a href="#router.METHOD">router.METHOD()</a>
                    </li>
                    <li><a href="#router.param">router.param()</a>
                    </li>
                    <li><a href="#router.route">router.route()</a>
                    </li>
                    <li><a href="#router.use">router.use()</a>
                    </li>
                </ul>
            </li>
        </ul>
        <div id="overlay"></div>
        <div id="api-doc">
            <h1>Express 4.x API 中文手册</h1>
            <p>
                <a id="express" class="h2"></a>
            </p>
            <h2>express()</h2>
            <p>创建一个 Express 应用。<code>express()</code> 是一个由 <em>express</em> 模块导出的入口（top-level）函数。</p>
            <pre><code class="language-js">var express = require('express');
var app = express();
</code></pre>
            <h3 id="express.methods">内置方法</h3>
            <section>
                <h3 id="express.static" class="h2">express.static(root, [options])</h3>
                <p><code>express.static</code> 是 Express 内置的唯一一个中间件。是基于 <a href="https://github.com/expressjs/serve-static">serve-static</a> 开发的，负责托管 Express 应用内的静态资源。</p>
                <p><code>root</code> 参数指的是静态资源文件所在的根目录。</p>
                <p><code>options</code> 对象是可选的，支持以下属性：</p>
                <table>
                    <thead>
                        <tr>
                            <th>属性</th>
                            <th>描述</th>
                            <th>类型</th>
                            <th>默认值</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>dotfiles</code></td>
                            <td>Option for serving dotfiles. Possible values are “allow”, “deny”, and “ignore”</td>
                            <td>String</td>
                            <td>“ignore”</td>
                        </tr>
                        <tr>
                            <td><code>etag</code></td>
                            <td>Enable or disable etag generation</td>
                            <td>Boolean</td>
                            <td><code>true</code></td>
                        </tr>
                        <tr>
                            <td><code>extensions</code></td>
                            <td>Sets file extension fallbacks.</td>
                            <td>Boolean</td>
                            <td><code>false</code></td>
                        </tr>
                        <tr>
                            <td><code>index</code></td>
                            <td>Sends directory index file. Set <code>false</code> to disable directory indexing.</td>
                            <td>Mixed</td>
                            <td>“index.html”</td>
                        </tr>
                        <tr>
                            <td><code>lastModified</code></td>
                            <td>Set the <code>Last-Modified</code> header to the last modified date of the file on the OS. Possible values are <code>true</code> or <code>false</code>.</td>
                            <td>Boolean</td>
                            <td><code>true</code></td>
                        </tr>
                        <tr>
                            <td><code>maxAge</code></td>
                            <td>Set the max-age property of the Cache-Control header in milliseconds or a string in <a href="https://www.npmjs.org/package/ms">ms format</a></td>
                            <td>Number</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td><code>redirect</code></td>
                            <td>Redirect to trailing “/” when the pathname is a directory.</td>
                            <td>Boolean</td>
                            <td><code>true</code></td>
                        </tr>
                        <tr>
                            <td><code>setHeaders</code></td>
                            <td>Function for setting HTTP headers to serve with the file.</td>
                            <td>Function</td>
                            <td> </td>
                        </tr>
                    </tbody>
                </table>
                <p>关于此中间件的细节，请参考 <a href="/starter/static-files.html">通过 Express 托管静态资源文件</a>。</p>
            </section>
            <p>
                <a id="app" class="h2"></a>
            </p>
            <h2>Application</h2>
            <p>The <code>app</code> object conventionally denotes the Express application. Create it by calling the top-level <code>express()</code> function exported by the Express module:</p>
            <p>app对象通常是指通过express模块导入的全局函数exress()的一个实例,</p>
            <pre><code class="language-js">var express = require('express');
var app = express();

app.get('/', function(req, res){
  res.send('hello world');
});

app.listen(3000);
</code></pre>
            <p>The <code>app</code> object has methods for</p>
            <p> <code>app</code> 对象有以下方法</p>
            <ul>
                <li>Routing HTTP requests; see for example, <a href="#app.METHOD">app.METHOD</a> and <a href="#app.param">app.param</a>.
                    <p>路由和请求; 具体实例请查看,<a href="#app.METHOD">app.METHOD</a> and <a href="#app.param">app.param</a>.</p>
                </li>
                <li>Configuring middleware; see <a href="#app.route">app.route</a>.
                    <p>中间层配置项,<a href="#app.route">app.route</a>.</p>
                </li>
                <li>Rendering HTML views; see <a href="#app.render">app.render</a>.
                    <p>视图层渲染，<a href="#app.render">app.render</a></p>
                </li>
                <li>Registering a template engine; see <a href="#app.engine">app.engine</a>.
                    <p>模板引擎：<a href="#app.engine">app.engine</a></p>
                </li>
            </ul>
            <p>It also has settings (properties) that affect how the application behaves; for more information, see <a href="#app.settings.table">Application settings</a>.</p>
            <p>app对象也有一些设置（属性）能影响实例的表现，点击锚链接获取更多信息<a href="#app.settings.table">实例设置</a>.</p>
            <h3 id="app.properties">Properties（属性）</h3>
            <section>
                <h3 id="app.locals">app.locals</h3>
                <p>The <code>app.locals</code> object is a JavaScript object, and its properties are local variables within the application.</p>
                <p>The <code>app.locals</code>是一个js对象, 它的属性是实例内的局部变量.</p>
                <pre><code class="language-js">app.locals.title
// =&gt; 'My App'

app.locals.email
// =&gt; 'me@myapp.com'
</code></pre>
                <p>Once set, the value of <code>app.locals</code> properties persist throughout the life of the application, in contrast with <a href="#res.locals">res.locals</a> properties that are valid only for the lifetime of the request.</p>
                <p>一旦赋值完毕, <code>app.locals</code> 的值会一直存在在当前实例, 而<a href="#res.locals">res.locals</a>，只存在于HTTP请求的周期内</p>
                <p>You can access local variables in templates rendered within the application. This is useful for providing helper functions to templates, as well as app-level data. Note, however, that you cannot access local variables in middleware.</p>
                <p>你能获取渲染后的模板内的局部变量,这个有助于渲染模板。小提示：你不能在中间层获取到局部变量 </p>
                <pre><code class="language-js">app.locals.title = 'My App';
app.locals.strftime = require('strftime');
app.locals.email = 'me@myapp.com';
</code></pre>
            </section>
            <section>
                <h3 id="app.mountpath">app.mountpath</h3>
                <p>The <code>app.mountpath</code> property is the path pattern(s) on which a sub app was mounted.</p>
                <p><code>app.mountpath</code> 属性是指下级节点挂载的路径</p>
                <div class="doc-box doc-info">
                    <p>a sub app 可能是用来处理路由请求的一个express实例节点 </p>
                    <p></p>
                </div>
                <pre><code class="language-js">var express = require('express');

var app = express(); // the main app 主节点
var admin = express(); // the sub app 子节点

admin.get('/', function (req, res) {
  console.log(admin.mountpath); // /admin
  res.send('Admin Homepage');
})

app.use('/admin', admin); // mount the sub app 把admin挂载到主节点app的'/admin'路径下
</code></pre>
                <p>It is similar to the <a href="#req.baseUrl">baseUrl</a> property of the <code>req</code> object, except <code>req.baseUrl</code> returns the matched URL path, instead of the matched pattern(s).</p>
                <p>这个很像req对象的一个属性 <a href="#req.baseUrl">baseUrl</a> , 但req.baseUrl返回的是匹配到的路径, 而不是路径匹配规则</p>
                <p>If a sub-app is mounted on multiple path patterns, <code>app.mountpath</code> returns the list of patterns it is mounted on, as shown in the following example.</p>
                <p>如果一个子节点有多个路径规则，则会返回一个路径列表</p>
                <pre><code class="language-js">var admin = express();

admin.get('/', function (req, res) {
  console.log(admin.mountpath); // [ '/adm*n', '/manager' ]
  res.send('Admin Homepage');
})

var secret = express();
secret.get('/', function (req, res) {
  console.log(secret.mountpath); // /secr*t
  res.send('Admin Secret');
});

admin.use('/secr*t', secret); // load the 'secret' router on '/secr*t', on the 'admin' sub app ||secret作为admin的子节点
app.use(['/adm*n', '/manager'], admin); // load the 'admin' router on '/adm*n' and '/manager', on the parent app||admin作为app的子节点
//   域名/adm*n/secr*t  或者 域名/manager/secr*t   都可以匹配到相同位置
</code></pre>
            </section>
            <h3 id="app.events">Events（事件）</h3>
            <section>
                <h3 id="app.onmount">app.on('mount', callback(parent))</h3>
                <p>The <code>mount</code> event is fired on a sub-app, when it is mounted on a parent app. The parent app is passed to the callback function.</p>
                <p> <code>mount</code> 事件能在子节点挂载到父节点的时候触发. 父节点作为参数传入回调的形参里.</p>
                <pre><code class="language-js">var admin = express();

admin.on('mount', function (parent) {
  console.log('Admin Mounted');
  console.log(parent); // refers to the parent app ||父节点
});

admin.get('/', function (req, res) {
  res.send('Admin Homepage');
});

app.use('/admin', admin);
</code></pre>
            </section>
            <h3 id="app.methods">Methods（方法）</h3>
            <section>
                <h3 id="app.all">app.all(path, callback [, callback ...])</h3>
                <p>This method is like the standard <a href="#app.METHOD">app.METHOD()</a> methods, except it matches all HTTP verbs.</p>
                <p>这个方法像一个方法集合<a href="#app.METHOD">app.METHOD()</a> ,但他能匹配所有的HTTP请求</p>
                <p>It’s useful for mapping “global” logic for specific path prefixes or arbitrary matches. For example, if you put the following at the top of all other route definitions, it requires that all routes from that point on require authentication, and automatically load a user. Keep in mind that these callbacks do not have to act as end-points: <code>loadUser</code> can perform a task, then call <code>next()</code> to continue matching subsequent routes.
                </p>
                <p>它对实现特定前缀的路径或者所有路径匹配一个全局规则很有帮助. 比如，你下面的代码放在其他路由定义前面, 它就会要求所有路由需要一个身份验证, 并且自动初始化一个用户.注意:这些回调函数不会表现得像请求-响应模式一样 <code>loadUser</code> 能自己开启一个任务, 然后使用 <code>next()</code> 自己匹配下面的路由规则.
                </p>
                <pre><code class="language-js">app.all('*', requireAuthentication, loadUser);
</code></pre>
                <p>Or the equivalent:</p>
                <pre><code class="language-js">app.all('*', requireAuthentication)
app.all('*', loadUser);
</code></pre>
                <p>Another example is white-listed “global” functionality. The example is much like before, however it only restricts paths that start with “/api”:
                </p>
                <p>另一个例子是给全局添加到白名单. 只是严格匹配了'/api'路径 :
                </p>
                <p>:
                </p>
                <pre><code class="language-js">app.all('/api/*', requireAuthentication);
</code></pre>
            </section>
            <section>
                <h3 id="app.delete.method">app.delete(path, callback [, callback ...])</h3>
                <p>Routes HTTP DELETE requests to the specified path with the specified callback functions. For more information, see the <a href="/guide/routing.html">routing guide</a>.</p>
                <p>对特定路径的HTTP DELETE 请求请查看<a href="http://www.expressjs.com.cn/guide/routing.html">routing guide</a>.</p>
                <p>You can provide multiple callback functions that behave just like middleware, except these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p>
                <p>你能像中间层一样提供多个回调函数, 除了那些 能被剩余路由影响的回调 <code>next('route')</code> . 你能通过这样给路由设置前置条件, 如果当前路由逻辑结束就可以交给下级路由</p>
                <pre><code class="language-js">app.delete('/', function (req, res) {
  res.send('DELETE request to homepage');
});
</code></pre>
            </section>
            <section>
                <h3 id="app.disable">app.disable(name)</h3>
                <p>Sets the Boolean setting <code>name</code> to <code>false</code>, where <code>name</code> is one of the properties from the <a href="#app.settings.table">app settings table</a>. Calling <code>app.set('foo', false)</code> for a Boolean property is the same as calling <code>app.disable('foo')</code>.</p>
                <p>S设置 <code>name</code>布尔值为 to <code>false</code>, <code>name</code> 是 <a href="#app.settings.table">app settings table</a>里的一个属性. <code>app.set('foo', false)</code> 等同于<code>app.disable('foo')</code>.</p>
                <p>For example:</p>
                <pre><code class="language-js">app.disable('trust proxy');
app.get('trust proxy');
// =&gt; false
</code></pre>
            </section>
            <section>
                <h3 id="app.disabled">app.disabled(name)</h3>
                <p>Returns <code>true</code> if the Boolean setting <code>name</code> is disabled (<code>false</code>), where <code>name</code> is one of the properties from the <a href="#app.settings.table">app settings table</a>.</p>
                <p>
                    </code> 如果<code>name</code> 为 (<code>false</code>),返回 <code>true ，<code>name</code> <a href="#app.settings.table">app settings table</a>里的一个属性.</p>
                <pre><code class="language-js">app.disabled('trust proxy');
// =&gt; true

app.enable('trust proxy');
app.disabled('trust proxy');
// =&gt; false
</code></pre>
            </section>
            <section>
                <h3 id="app.enable">app.enable(name)</h3>
                <p>Sets the Boolean setting <code>name</code> to <code>true</code>, where <code>name</code> is one of the properties from the <a href="#app.settings.table">app settings table</a>. Calling <code>app.set('foo', true)</code> for a Boolean property is the same as calling <code>app.enable('foo')</code>.</p>
                <p>设置<code>name</code> 为 <code>true</code>, <code>name</code> 是 <a href="#app.settings.table">app settings table</a>里的一个属性. <code>app.set('foo', true)</code> 等同于 <code>app.enable('foo')</code>.</p>
                <pre><code class="language-js">app.enable('trust proxy');
app.get('trust proxy');
// =&gt; true
</code></pre>
            </section>
            <section>
                <h3 id="app.enabled">app.enabled(name)</h3>
                <p>Returns <code>true</code> if the setting <code>name</code> is enabled (<code>true</code>), where <code>name</code> is one of the properties from the <a href="#app.settings.table">app settings table</a>.</p>
                <p>假如 name 为真 , 返回true, <code>name</code> 是 <a href="#app.settings.table">app settings table</a>里的一个属性.</p>
                <pre><code class="language-js">app.enabled('trust proxy');
// =&gt; false

app.enable('trust proxy');
app.enabled('trust proxy');
// =&gt; true
</code></pre>
            </section>
            <section>
                <h3 id="app.engine">app.engine(ext, callback)</h3>
                <p>Registers the given template engine <code>callback</code> as <code>ext</code>.</p>
                <p>给指定文件类型设定模板引擎</p>
                <p>By default, Express will <code>require()</code> the engine based on the file extension. For example, if you try to render a “foo.jade” file, Express invokes the following internally, and caches the <code>require()</code> on subsequent calls to increase performance.
                </p>
                <p>默认设定是：express会基于文件后缀名调用模板引擎，假如我们想渲染foo.jade ，express会从内部调用，缓存起来以便于加快渲染
                </p>
                <pre><code class="language-js">app.engine('jade', require('jade').__express);
</code></pre>
                <p>Use this method for engines that do not provide <code>.__express</code> out of the box, or if you wish to “map” a different extension to the template engine.</p>
                <p>使用如下方法驱动其他类型文件 , 或者你想使用其他引擎</p>
                <p>比如，你想用ejs驱动HTML文件:</p>
                <pre><code class="language-js">app.engine('html', require('ejs').renderFile);
</code></pre>
                <p>In this case, EJS provides a <code>.renderFile()</code> method with the same signature that Express expects: <code>(path, options, callback)</code>, though note that it aliases this method as <code>ejs.__express</code> internally so if you’re using “.ejs” extensions you don’t need to do anything.</p>
                <p>在这个场景中，EJS提供了一个.renderFlie()方法，假如你使用.ejs后缀名，则只需要require进来，引擎会自动识别</p>
                <p>一些模板引擎不允许这样做.比如下面的目标，所以常用的模板引擎为ejs 和jada
                </p>
                <pre><code class="language-js">var engines = require('consolidate');
app.engine('haml', engines.haml);
app.engine('html', engines.hogan);
</code></pre>
            </section>
            <section>
                <h3 id="app.get">app.get(name)</h3>
                <p>返回app设置里name的值, <code>name</code> 是这个表里的属性<a href="#app.settings.table">app settings table</a>. 比如:</p>
                <pre><code class="language-js">app.get('title');
// =&gt; undefined

app.set('title', 'My Site');
app.get('title');
// =&gt; "My Site"
</code></pre>
            </section>
            <section>
                <h3 id="app.get.method">app.get(path, callback [, callback ...])</h3>
                <p>Routes HTTP GET requests to the specified path with the specified callback functions. For more information, see the <a href="/guide/routing.html">routing guide</a>.</p>
                <p>对不同路径的HTTP请求提供回调函数. 更多信息请查看<a href="/guide/routing.html">routing guide</a>.</p>
                <p>You can provide multiple callback functions that behave just like middleware, except these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p>
                <p>你能像中间层一样提供多个回调函数, 除了那些 能被剩余路由影响的回调 next('route').你能通过这个机制来给路由设置前置条件, 然后把控制权交给下级路由</p>
                <pre><code class="language-js">app.get('/', function (req, res) {
  res.send('GET request to homepage');
});
</code></pre>
            </section>
            <section>
                <h3 id="app.listen">app.listen(port, [hostname], [backlog], [callback])</h3>
                <p>Binds and listens for connections on the specified host and port. This method is identical to Node’s <a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback">http.Server.listen()</a>.</p>
                <p>监听特定的域名和端口的网络连接，这个方法和原生方法一致 <a href="http://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback">http.Server.listen()</a>.</p>
                <pre><code class="language-js">var express = require('express');
var app = express();
app.listen(3000);
</code></pre>
                <p>The <code>app</code> returned by <code>express()</code> is in fact a JavaScript Function, designed to be passed to Node’s HTTP servers as a callback to handle requests. This makes it easy to provide both HTTP and HTTPS versions of your app with the same code base, as the app does not inherit from these (it is simply a callback):</p>
                <p>变量app实际上是由express（）返回的一个JavaScript函数对象，被设计成一个传给Node HTTP服务器作为参数的回调函数，这就很容易让你使用相同的代码提供HTTPS和HTTP服务，app对象仅仅作为一个回调，不从此继承相关属性</p>
                <pre><code class="language-js">var express = require('express');
var https = require('https');
var http = require('http');
var app = express();

http.createServer(app).listen(80);
https.createServer(options, app).listen(443);
</code></pre>
                <p>The <code>app.listen()</code> method is a convenience method for the following (for HTTP only):</p>
                <p>app.listen()方法是实际上是一个http（s）服务的封装（示例只展示了http）</p>
                <pre><code class="language-js">app.listen = function() {
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};
</code></pre>
            </section>
            <section>
                <h3 id="app.METHOD">app.METHOD(path, callback [, callback ...])</h3>
                <p>Routes an HTTP request, where METHOD is the HTTP method of the request, such as GET, PUT, POST, and so on, in lowercase. Thus, the actual methods are app.get(), app.post(), app.put(), and so on. See below for the complete list.</p>
                <p>对不同路径的HTTP请求提供回调函数，method是一个http请求的方法，比如常见的GET,PUT,POST.....实际的方法为小写，app.get(),app.post(),app.put()...，你可以查看下面的列表寻找更多方法</p>
                <p>更多信息请查看 <a href="/guide/routing.html">routing guide</a>.</p>
                <p>express支持如下方法</p>
                <table style="border: 0px; background: none">
                    <tr>
                        <td style="background: none; border: 0px;">
                            <ul>
                                <li><code>checkout</code></li>
                                <li><code>connect</code></li>
                                <li><code>copy</code></li>
                                <li><code>delete</code></li>
                                <li><code>get</code></li>
                                <li><code>head</code></li>
                                <li><code>lock</code></li>
                                <li><code>merge</code></li>
                                <li><code>mkactivity</code></li>
                            </ul>
                        </td>
                        <td style="background: none; border: 0px;">
                            <ul>
                                <li><code>mkcol</code></li>
                                <li><code>move</code></li>
                                <li><code>m-search</code></li>
                                <li><code>notify</code></li>
                                <li><code>options</code></li>
                                <li><code>patch</code></li>
                                <li><code>post</code></li>
                                <li><code>propfind</code></li>
                                <li><code>proppatch</code></li>
                            </ul>
                        </td>
                        <td style="background: none; border: 0px;">
                            <ul>
                                <li><code>purge</code></li>
                                <li><code>put</code></li>
                                <li><code>report</code></li>
                                <li><code>search</code></li>
                                <li><code>subscribe</code></li>
                                <li><code>trace</code></li>
                                <li><code>unlock</code></li>
                                <li><code>unsubscribe</code></li>
                            </ul>
                        </td>
                    </tr>
                </table>
                <div class="doc-box doc-info">
                    <p>为了能使得使用了特殊符号的方法能正常运行,可以使用[]使其生效，比如
                        <code>app['m-search']('/', function ...</code>.</p>
                </div>
                <div class="doc-box doc-info">
                    <p>API文档仅仅列出来了最常用的HTTP请求方法，app.get(), app.post(), app.put(), and app.delete(). 当时未列出来的方法基本上和以上方法大同小异</p>
                </div>
                <p>There is a special routing method, <code>app.all()</code>, that is not derived from any HTTP method. It loads middleware at a path for all request methods.</p>
                <p>有一个特殊的路由方法, <code>app.all()</code>, 它不是由任何HTTP请求方法衍生而来. 它会在在匹配到的路径上处理任何请求</p>
                <p>In the following example, the handler is executed for requests to “/secret” whether using GET, POST, PUT, DELETE, or any other HTTP request method.</p>
                <p>在下面的例子中，回调会会处理任何请求不管请求方法是get， post，put，delete....</p>
                <pre><code class="language-js">app.all('/secret', function (req, res, next) {
  console.log('Accessing the secret section ...')
  next() // pass control to the next handler
})
</code></pre>
            </section>
            <section>
                <h3 id="app.param">app.param([name], callback)</h3>
                <p>Add callback triggers to route parameters, where <code>name</code> is the name of the parameter or an array of them, and <code>function</code> is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, and the value of the parameter, in that order.</p>
                <p>对路由路径参数添加回调，name是参数的名字或者参数数组，function是回调函数，回调函数的参数有 req，res，next(),和路径参数的值。</p>
                <p>If <code>name</code> is an array, the <code>callback</code> trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to <code>next</code> inside the callback will call the callback for the next declared parameter. For the last parameter, a call to <code>next</code> will call the next middleware in place for the route currently being processed, just like it would if <code>name</code> were just a string.</p>
                <p>如果name是数组，回调函数会对数组中的每一个声明的参数都生效，此外对除了最后一个的参数，next（）会调用下一个参数的回调</p>
                <p>For example, when <code>:user</code> is present in a route path, you may map user loading logic to automatically provide <code>req.user</code> to the route, or perform validations on the parameter input.</p>
                <p>例如,:user是当前路由的路径，你能加载一个逻辑自动提供req.user给路由</p>
                <pre><code class="language-js">app.param('user', function(req, res, next, id) {

  // try to get the user details from the User model and attach it to the request object
  User.find(id, function(err, user) {
    if (err) {
      next(err);
    } else if (user) {
      req.user = user;
      next();
    } else {
      next(new Error('failed to load user'));
    }
  });
});
</code></pre>
                <p>Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers. Hence, param callbacks defined on <code>app</code> will be triggered only by route parameters defined on <code>app</code> routes.</p>
                <p>参数回调会在被定义的地方局部注册，他们不会被挂载的主节点或者路由继承，因此Param回调只会被在被定义的路由下继承</p>
                <p>All param callbacks will be called before any handler of any route in which the param occurs, and they will each be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.</p>
                <p>所有的参数回调会优先调用，而且在请求响应周期内只会调用一次，即使请求路径拥有多个回调.</p>
                <pre><code class="language-js">app.param('id', function (req, res, next, id) {
  console.log('CALLED ONLY ONCE');
  next();
})

app.get('/user/:id', function (req, res, next) {
  console.log('although this matches');
  next();
});

app.get('/user/:id', function (req, res) {
  console.log('and this matches too');
  res.end();
});
</code></pre>
                <p>On <code>GET /user/42</code>, the following is printed:</p>
                <pre><code>CALLED ONLY ONCE
although this matches
and this matches too
</code></pre>
                <pre><code class="language-js">app.param(['id', 'page'], function (req, res, next, value) {
  console.log('CALLED ONLY ONCE with', value);
  next();
})

app.get('/user/:id/:page', function (req, res, next) {
  console.log('although this matches');
  next();
});

app.get('/user/:id/:page', function (req, res) {
  console.log('and this matches too');
  res.end();
});
</code></pre>
                <p>On <code>GET /user/42/3</code>, the following is printed:</p>
                <pre><code>CALLED ONLY ONCE with 42
CALLED ONLY ONCE with 3
although this matches
and this matches too
</code></pre>
                <div class="doc-box doc-warn">
                    <p>下面的<code>app.param(callback)</code>描述在v4.11.0版本不赞成使用</p>
                </div>
                <p>The behavior of the <code>app.param(name, callback)</code> method can be altered entirely by passing only a function to <code>app.param()</code>. This function is a custom implementation of how <code>app.param(name, callback)</code> should behave - it accepts two parameters and must return a middleware.</p>
                <p>app.param方法也能只传一个参数.这样并不像app.param(name, callback)传两个参数返回一个中间层一样直观。</p>
                <p>The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation.</p>
                <p>回调的第一个参数是param名.第二个参数可以是任何JavaScript对象</p>
                <p>The middleware returned by the function decides the behavior of what happens when a URL parameter is captured.</p>
                <p>这个回调函数返回的中间层会决定URL地址被捕获到时的行为.</p>
                <p>In this example, the <code>app.param(name, callback)</code> signature is modified to <code>app.param(name, accessId)</code>. Instead of accepting a name and a callback, <code>app.param()</code> will now accept a name and a number.</p>
                <p>这个例子中，app.param(name, callback)被修饰成app.param(name, accessId)，而不是接受name和回调，现在app.param()将接受一个name和数字作为参数</p>
                <pre><code class="language-js">var express = require('express');
var app = express();

// customizing the behavior of app.param()
app.param(function(param, option) {
  return function (req, res, next, val) {
    if (val == option) {
      next();
    }
    else {
      res.sendStatus(403);
    }
  }
});

// using the customized app.param()
app.param('id', 1337);

// route to trigger the capture
app.get('/user/:id', function (req, res) {
  res.send('OK');
})

app.listen(3000, function () {
  console.log('Ready');
})
</code></pre>
                <p>In this example, the <code>app.param(name, callback)</code> signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id.</p>
                <p>在这个例子中，app.param(name, callback)得到保留，但是callback被替换成一个中间件，一个校验函数被用来检测user的id.</p>
                <pre><code class="language-js">app.param(function(param, validator) {
  return function (req, res, next, val) {
    if (validator(val)) {
      next();
    }
    else {
      res.sendStatus(403);
    }
  }
})

app.param('id', function (candidate) {
  return !isNaN(parseFloat(candidate)) &amp;&amp; isFinite(candidate);
});
</code></pre>
                <div class="doc-box doc-info">
                    <p>The ‘<code>.</code>’ character can’t be used to capture a character in your capturing regexp. For example you can’t use <code>'/user-.+/'</code> to capture <code>'users-gami'</code>, use <code>[\\s\\S]</code> or <code>[\\w\\W]</code> instead (as in <code>'/user-[\\s\\S]+/'</code>.</p>
                    <p>Examples:</p>
                    <pre><code class="language-js">//captures '1-a_6' but not '543-azser-sder'
router.get('/[0-9]+-[[\\w]]*', function); 

//captures '1-a_6' and '543-az(ser"-sder' but not '5-a s'
router.get('/[0-9]+-[[\\S]]*', function); 

//captures all (equivalent to '.*')
router.get('[[\\s\\S]]*', function); 
</code></pre>
                </div>
            </section>
            <section>
                <h3 id="app.path">app.path()</h3>
                <p>Returns the canonical path of the app, a string.</p>
                <p>返回一个app节点的路径的字符串.</p>
                <pre><code class="language-js">var app = express()
  , blog = express()
  , blogAdmin = express();

app.use('/blog', blog);
blog.use('/admin', blogAdmin);

console.log(app.path()); // ''
console.log(blog.path()); // '/blog'
console.log(blogAdmin.path()); // '/blog/admin'
</code></pre>
                <p>The behavior of this method can become very complicated in complex cases of mounted apps: it is usually better to use <a href="#req.baseUrl">req.baseUrl</a> to get the canonical path of the app.</p>
                <p>这个方法的表现复杂的多节点项目下会变得更加复杂，通常选择使用<a href="#req.baseUrl">req.baseUrl</a>来获得规范的路径.</p>
            </section>
            <section>
                <h3 id="app.post.method">app.post(path, callback [, callback ...])</h3>
                <p>Routes HTTP POST requests to the specified path with the specified callback functions. For more information, see the <a href="/guide/routing.html">routing guide</a>.</p>
                <p>对不同路径的HTTP POST请求提供回调函数</p>
                <p>You can provide multiple callback functions that behave just like middleware, except that these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p>
                <p>你能像中间层一样提供多个回调函数, 除了那些 能被剩余路由影响的回调 next('route').你能通过这个机制来给路由设置前置条件, 然后把控制权交给下级路由</p>
                <pre><code class="language-js">app.post('/', function (req, res) {
  res.send('POST request to homepage');
});
</code></pre>
            </section>
            <section>
                <h3 id="app.put.method">app.put(path, callback [, callback ...])</h3>
                <p>Routes HTTP PUT requests to the specified path with the specified callback functions. For more information, see the <a href="/guide/routing.html">routing guide</a>.</p>
                <p>对不同路径的HTTP PUT请求提供回调函数</p>
                <p>You can provide multiple callback functions that behave just like middleware, except that these callbacks can invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to impose pre-conditions on a route, then pass control to subsequent routes if there’s no reason to proceed with the current route.</p>
                <pre><code class="language-js">app.put('/', function (req, res) {
  res.send('PUT request to homepage');
});
</code></pre>
            </section>
            <section>
                <h3 id="app.render">app.render(view, [locals], callback)</h3>
                <p>Returns the rendered HTML of a view via the <code>callback</code> function. It accepts an optional parameter that is an object containing local variables for the view. It is like <a href="#res.render">res.render()</a>, except it cannot send the rendered view to the client on its own.</p>
                <p>通过回调函数渲染HTML视图.它可以接收一个视图层的局部变量组成的对象，有点像res.render()，除了它不能发送渲染的视图给客户端</p>
                <div class="doc-box doc-info">
                    <p>Think of <code>app.render()</code> as a utility function for generating rendered view strings. Internally <code>res.render()</code> uses <code>app.render()</code> to render views.</p>
                    <p>把app.render()当做一个用来渲染静态字符的函数.res.render()本质上是用app.render()来渲染视图</p>
                </div>
                <div class="doc-box doc-notice">
                    <p>The local variable <code>cache</code> is reserved for enabling view cache. Set it to <code>true</code>, if you want to cache view during development; view caching is enabled in production by default.</p>
                </div>
                <pre><code class="language-js">app.render('email', function(err, html){
  // ...
});

app.render('email', { name: 'Tobi' }, function(err, html){
  // ...
});
</code></pre>
            </section>
            <section>
                <h3 id="app.route">app.route(path)</h3>
                <p>Returns an instance of a single route, which you can then use to handle HTTP verbs with optional middleware. Use <code>app.route()</code> to avoid duplicate route names (and thus typo errors).</p>
                <p>返回一个路由的实例，你能用可选的中间件来处理http请求，使用app.route()来避免重复多次路由名称.</p>
                <pre><code class="language-js">var app = express();

app.route('/events')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
})
.get(function(req, res, next) {
  res.json(...);
})
.post(function(req, res, next) {
  // maybe add a new event...
})
</code></pre>
            </section>
            <section>
                <h3 id="app.set">app.set(name, value)</h3>
                <p>Assigns setting <code>name</code> to <code>value</code>, where <code>name</code> is one of the properties from the <a href="#app.settings.table">app settings table</a>.</p>
                <p>为name设置值，name是一个属性<a href="#app.settings.table">app settings table</a>.</p>
                <p>对布尔值来说，app.set('name',true)相当于app.enable('name')，类似的app.set('name',false)相当于app.disabled('name').</p>
                <p>获得设置的值则使用 <a href="#app.get"><code>app.get()</code></a>.</p>
                <pre><code class="language-js">app.set('title', 'My Site');
app.get('title'); // "My Site"
</code></pre>
                <h4 id="app.settings.table">Application Settings</h4>
                <p>如果name是应用中的设置项，它会影响整个应用的表现，下面的列表是应用设置项.</p>
                <div class="table-scroller">
                    <table class="doctable" border="1">
                        <thead>
                            <tr>
                                <th id="app-settings-property">Property</th>
                                <th>Type</th>
                                <th>Value</th>
                                <th>Default</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>
                                    <p><code>case sensitive routing</code></p>
                                </td>
                                <td>Boolean</td>
                                <td>Enable case sensitivity.</td>
                                <td>Disabled. Treats "/Foo" and "/foo" as the same.</td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>env</code></p>
                                </td>
                                <td>String</td>
                                <td>Environment mode.</td>
                                <td>
                                    <p><code>process.env.NODE_ENV</code> (<code>NODE_ENV</code> environment variable) or “development”.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>etag</code></p>
                                </td>
                                <td>Varied</td>
                                <td>
                                    <p>Set the ETag response header. For possible values, see the <a href="#etag.options.table"><code>etag</code> options table</a>.</p>
                                    <p><a href="http://en.wikipedia.org/wiki/HTTP_ETag">More about the HTTP ETag header</a>.</p>
                                </td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>jsonp callback name</code></p>
                                </td>
                                <td>String</td>
                                <td>Specifies the default JSONP callback name.</td>
                                <td>
                                    <p><code>?callback=</code></p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>json replacer</code></p>
                                </td>
                                <td>String</td>
                                <td>JSON replacer callback.</td>
                                <td>
                                    <p><code>null</code></p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>json spaces</code></p>
                                </td>
                                <td>Number</td>
                                <td>When set, sends prettified JSON string indented with the specified amount of spaces.</td>
                                <td>Disabled.</td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>query parser</code></p>
                                </td>
                                <td>String</td>
                                <td>
                                    <p>The query parser to use, either “simple” or “extended”. The simple query parser is based on Node’s native query parser, <a href="http://nodejs.org/api/querystring.html">querystring</a>. The extended query parser is based on <a href="https://www.npmjs.org/package/qs">qs</a>.</p>
                                </td>
                                <td>"extended"</td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>strict routing</code></p>
                                </td>
                                <td>Boolean</td>
                                <td>Enable strict routing.</td>
                                <td>Disabled. Treats "/foo" and "/foo/" as the same by the router.</td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>subdomain offset</code></p>
                                </td>
                                <td>Number</td>
                                <td>The number of dot-separated parts of the host to remove to access subdomain.</td>
                                <td>2</td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>trust proxy</code></p>
                                </td>
                                <td>Varied</td>
                                <td>
                                    <p>Indicates the app is behind a front-facing proxy, and to use the <code>X-Forwarded-*</code> headers to determine the connection and the IP address of the client. NOTE: <code>X-Forwarded-*</code> headers are easily spoofed and the detected IP addresses are unreliable.</p>
                                    <p><code>trust proxy</code> is disabled by default. When enabled, Express attempts to determine the IP address of the client connected through the front-facing proxy, or series of proxies. The <code>req.ips</code> property, then, contains an array of IP addresses the client is connected through. To enable it, use the values described in the <a href="#trust.proxy.options.table"><code>trust proxy</code> options table</a>.</p>
                                    <p>The <code>trust proxy</code> setting is implemented using the <a href="https://www.npmjs.org/package/proxy-addr">proxy-addr</a> package. For more information, see its documentation.</p>
                                </td>
                                <td>Disabled.</td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>views</code></p>
                                </td>
                                <td>String or Array</td>
                                <td>A directory or an array of directories for the application's views. If an array, the views are looked up in the order they occur in the array.</td>
                                <td>
                                    <p><code>process.cwd() + '/views'</code></p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>view cache</code></p>
                                </td>
                                <td>Boolean</td>
                                <td>Enables view template compilation caching.</td>
                                <td>
                                    <p><code>true</code> in production.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>view engine</code></p>
                                </td>
                                <td>String</td>
                                <td>The default engine extension to use when omitted.</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>
                                    <p><code>x-powered-by</code></p>
                                </td>
                                <td>Boolean</td>
                                <td>Enables the "X-Powered-By: Express" HTTP header.</td>
                                <td>
                                    <p><code>true</code></p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5 id="trust.proxy.options.table">Options for `trust proxy` setting</h5>
                    <table class="doctable" border="1">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Boolean</td>
                                <td>
                                    <p>If <code>true</code>, the client’s IP address is understood as the left-most entry in the <code>X-Forwarded-*</code> header.</p>
                                    <p>If <code>false</code>, the app is understood as directly facing the Internet and the client’s IP address is derived from <code>req.connection.remoteAddress</code>. This is the default setting.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>IP addresses</td>
                                <td>
                                    <p>An IP address, subnet, or an array of IP addresses, and subnets to trust. The following is the list of pre-configured subnet names.</p>
                                    <ul>
                                        <li>loopback - <code>127.0.0.1/8</code>, <code>::1/128</code></li>
                                        <li>linklocal - <code>169.254.0.0/16</code>, <code>fe80::/10</code></li>
                                        <li>uniquelocal - <code>10.0.0.0/8</code>, <code>172.16.0.0/12</code>, <code>192.168.0.0/16</code>, <code>fc00::/7</code></li>
                                    </ul>
                                    <p>Set IP addresses in any of the following ways:</p>
                                    <pre><code class="language-js">app.set('trust proxy', 'loopback') // specify a single subnet
  app.set('trust proxy', 'loopback, 123.123.123.123') // specify a subnet and an address
  app.set('trust proxy', 'loopback, linklocal, uniquelocal') // specify multiple subnets as CSV
  app.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal']) // specify multiple subnets as an array</code></pre>
                                    <p>When specified, the IP addresses or the subnets are excluded from the address determination process, and the untrusted IP address nearest to the application server is determined as the client’s IP address.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>Number</td>
                                <td>
                                    <p>Trust the <code>n</code>th hop from the front-facing proxy server as the client.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>Function</td>
                                <td>
                                    <p>Custom trust implementation. Use this only if you know what you are doing.</p>
                                    <pre><code class="language-js">app.set('trust proxy', function (ip) {
    if (ip === '127.0.0.1' || ip === '123.123.123.123') return true; // trusted IPs
    else return false;
  })</code></pre>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                    <h5 id="etag.options.table">Options for `etag` setting</h5>
                    <table class="doctable" border="1">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Boolean</td>
                                <td>
                                    <p><code>true</code> enables weak ETag. This is the default setting.
                                        <br />
                                        <code>false</code> disables ETag altogether.</p>
                                </td>
                            </tr>
                            <tr>
                                <td>String</td>
                                <td>
                                    If "strong", enables strong ETag.
                                    <br /> If "weak", enables weak ETag.
                                </td>
                            </tr>
                            <tr>
                                <td>Function</td>
                                <td>
                                    <p>Custom ETag function implementation. Use this only if you know what you are doing.</p>
                                    <pre><code class="language-js">app.set('etag', function (body, encoding) {
  return generateHash(body, encoding); // consider the function is defined
  })</code></pre>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>
            <section>
                <h3 id="app.use">app.use([path,] function [, function...])</h3>
                <p>Mounts the <a href="/guide/using-middleware.html">middleware</a> <code>function</code>(s) at the <code>path</code>. If <code>path</code> is not specified, it defaults to “/”.</p>
                <p>挂载中间件函数到路径上，如果路径没有指定，默认为'/'</p>
                <div class="doc-box doc-info">
                    <p>A route will match any path, which follows its path immediately with a “<code>/</code>”. For example: <code>app.use('/apple', ...)</code> will match “/apple”, “/apple/images”, “/apple/images/news”, and so on.</p>
                </div>
                <div class="doc-box doc-info">
                    <p><code>req.originalUrl</code> in a middleware is a combination of <code>req.baseUrl</code> and <code>req.path</code>, as shown in the following example.</p>
                    <pre><code class="language-js">app.use('/admin', function(req, res, next) {
  // GET 'http://www.example.com/admin/new'
  console.log(req.originalUrl); // '/admin/new'
  console.log(req.baseUrl); // '/admin'
  console.log(req.path); // '/new'
  next();
});
</code></pre>
                </div>
                <p>Mounting a middleware at a <code>path</code> will cause the middleware function to be executed whenever the base of the requested path matches the <code>path</code>.</p>
                <p>挂载一个中间件在某个路径上会使得这个中间件函数在路径被成功匹配到的时候会被激活</p>
                <p>Since <code>path</code> defaults to “/”, middleware mounted without a path will be executed for every request to the app.</p>
                <p>路径的默认值是'/'，没有路径的中间件会被应用的每一个请求所激活</p>
                <pre><code class="language-js">// this middleware will be executed for every request to the app
app.use(function (req, res, next) {
  console.log('Time: %d', Date.now());
  next();
})
</code></pre>
                <p>Middleware functions are executed sequentially, therefore the order of middleware inclusion is important.</p>
                <p>中间件函数会继续执行，因此中间件的顺序也十分重要</p>
                <pre><code class="language-js">
                // this middleware will not allow the request to go beyond it
                //请求无法继续向下
app.use(function(req, res, next) {
  res.send('Hello World');
})

// requests will never reach this route
//请求不会到达此路由
app.get('/', function (req, res) {
  res.send('Welcome');
})
</code></pre>
                <p><code>path</code> can be a string representing a path, a path pattern, a regular expression to match paths, or an array of combinations thereof.</p>
                <p>path 可以是一个路径字符串，路径模式，一个正则匹配路径，或者他们的组合</p>
                <div class="doc-box doc-notice">
                    <p>The middleware in the below are simple examples.</p>
                    <p>下面是一些简单的中间件</p>
                </div>
                <div class="table-scroller">
                    <table class="doctable" border="1">
                        <thead>
                            <tr>
                                <th> Type </th>
                                <th> Example </th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Path 路径</td>
                                <td><pre><code class="language-js">//会匹配路径/abcd
app.use('/abcd', function (req, res, next) {
  next();
})</code></pre>
                                </td>
                            </tr>
                            <tr>
                                <td>Path Pattern 路径模式</td>
                                <td>
                                    <pre><code class="language-js">// 匹配 /abcd 和 /abd
app.use('/abc?d', function (req, res, next) {
  next();
})

// 匹配 /abcd, /abbcd, /abbbbbcd 
app.use('/ab+cd', function (req, res, next) {
  next();
})

// will match paths starting with /abcd, /abxcd, /abFOOcd, /abbArcd and so on
app.use('/ab\*cd', function (req, res, next) {
  next();
})

// will match paths starting with /ad and /abcd
app.use('/a(bc)?d', function (req, res, next) {
  next();
})</code></pre>
                                </td>
                            </tr>
                            <tr>
                                <td>Regular Expression</td>
                                <td>
                                    <pre><code class="language-js">// will match paths starting with /abc and /xyz
app.use(/\/abc|\/xyz/, function (req, res, next) {
  next();
})</code></pre>
                                </td>
                            </tr>
                            <tr>
                                <td>Array</td>
                                <td>
                                    <pre><code class="language-js">// will match paths starting with /abcd, /xyza, /lmn, and /pqr
app.use(['/abcd', '/xyza', /\/lmn|\/pqr/], function (req, res, next) {
  next();
})</code></pre>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p><code>function</code> can be a middleware function, a series of middleware functions, an array of middleware functions, or a combination of all of them. Since <a href="#router">router</a> and <a href="#application">app</a> implement the middleware interface, you can use them as you would any other middleware function.</p>
                <p>函数能是中间件函数，一串中间件函数，一个数组集合的中间件函数，或者一个他们的集合，由于路由和app实现了中间件接口，你可以像其他中间件函数一样使用它</p>
                <table class="doctable" border="1">
                    <thead>
                        <tr>
                            <th>Usage</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Single Middleware</td>
                            <td>你可以定义和挂载局部中间件函数.
                                <pre><code class="language-js">app.use(function (req, res, next) {
  next();
})
</code></pre> 路由是合法的中间件.
                                <pre><code class="language-js">var router = express.Router();
router.get('/', function (req, res, next) {
  next();
})
app.use(router);
</code></pre> 一个express实例也是一个合法的中间件.
                                <pre><code class="language-js">var subApp = express();
subApp.get('/', function (req, res, next) {
  next();
})
app.use(subApp);
</code></pre>
                            </td>
                        </tr>
                        <tr>
                            <td>Series of Middleware</td>
                            <td>
                                你可以在同一个路径上使用多个中间件函数.
                                <pre><code class="language-js">var r1 = express.Router();
r1.get('/', function (req, res, next) {
  next();
})

var r2 = express.Router();
r2.get('/', function (req, res, next) {
  next();
})

app.use(r1, r2);
</code></pre>
                            </td>
                        </tr>
                        <tr>
                            <td>Array</td>
                            <td>使用数组来组合中间件，如果你传一个数组作为第一个参数，你必须注意区别挂载路径.
                                <pre><code class="language-js">var r1 = express.Router();
r1.get('/', function (req, res, next) {
  next();
})

var r2 = express.Router();
r2.get('/', function (req, res, next) {
  next();
})

app.use('/', [r1, r2]);
</code></pre>
                            </td>
                        </tr>
                        <tr>
                            <td>Combination</td>
                            <td>
                                你也可以兼用以上挂载中间件的方法.
                                <pre><code class="language-js">function mw1(req, res, next) { next(); }
function mw2(req, res, next) { next(); }

var r1 = express.Router();
r1.get('/', function (req, res, next) { next(); });

var r2 = express.Router();
r2.get('/', function (req, res, next) { next(); });

var subApp = express();
subApp.get('/', function (req, res, next) { next(); });

app.use(mw1, [mw2, r1, r2], subApp);
</code></pre>
                            </td>
                        </tr>
                    </tbody>
                </table>
                <p>Following are some examples of using the <a href="/guide/using-middleware.html#middleware.built-in">express.static</a> middleware in an Express app.</p>
                <p>下面是一些使用express.static中间件的示例</p>
                <p>Serve static content for the app from the “public” directory in the application directory:</p>
                <p>把根目录下的public文件夹作为静态资源目录</p>
                <pre><code class="language-js">// GET /style.css etc
app.use(express.static(__dirname + '/public'));
</code></pre>
                <p>Mount the middleware at “/static” to serve static content only when their request path is prefixed with “/static”:</p>
                <p>把根目录下的public文件夹作为静态资源目录，并且挂载到/static</p>
                <pre><code class="language-js">// GET /static/style.css etc.
app.use('/static', express.static(__dirname + '/public'));
</code></pre>
                <p>Disable logging for static content requests by loading the logger middleware after the static middleware:</p>
                <p>通过加载logger中间件来禁用静态资源目录日志</p>
                <pre><code class="language-js">app.use(express.static(__dirname + '/public'));
app.use(logger());
</code></pre>
                <p>Serve static files from multiple directories, but give precedence to “./public” over the others:</p>
                <p>从多个路径加载静态资源，但是给./public 更高的优先级</p>
                <pre><code class="language-js">app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads'));
</code></pre>
            </section>
            <p>
                <a id="req" class="h2"></a>
            </p>
            <h2>Request</h2>
            <p>The <code>req</code> object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention, the object is always referred to as <code>req</code> (and the HTTP response is <code>res</code>) but its actual name is determined by the parameters to the callback function in which you’re working.</p>
            <p>req对象是指HTTP的请求对象，并且带有很多请求属性，比如查询字符串，路径，请求主体，HTTP头部，等等。按照惯例，request对象一直是当成req（HTTP response是res），但是它实际的名称可以根据你的回调函数参数而改变。
            </p>
            <p>For example:</p>
            <pre><code class="language-js">app.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});
</code></pre>
            <p>But you could just as well have:</p>
            <pre><code class="language-js">app.get('/user/:id', function(request, response){
  response.send('user ' + request.params.id);
});
</code></pre>
            <h3 id="req.properties">Properties</h3>
            <div class="doc-box doc-notice">
                <p>In Express 4, <code>req.files</code> is no longer available on the <code>req</code> object by default. To access uploaded files on the <code>req.files</code> object, use a multipart-handling middleware like <a href="https://www.npmjs.com/package/busboy">busboy</a>, <a href="https://www.npmjs.com/package/multer">multer</a>, <a href="https://www.npmjs.com/package/formidable">formidable</a>, <a href="https://www.npmjs.com/package/multiparty">multiparty</a>, <a href="https://www.npmjs.com/package/connect-multiparty">connect-multiparty</a>, or <a href="https://www.npmjs.com/package/pez">pez</a>.</p>
                <p>在express 4中，req.files不在被默认支持，为了支持通过req.files对象上传文件，请使用分片上传中间层例如：busboy, multer, formidable, multiparty, connect-multiparty, or pez.</p>
            </div>
            <section>
                <h3 id="req.app">req.app</h3>
                <p>This property holds a reference to the instance of the express application that is using the middleware.</p>
                <p>这属性会指向当前使用此中间层的express应用</p>
                <p>If you follow the pattern in which you create a module that just exports a middleware in order for requiring it in your main file, then the middleware can access the express instance via <code>req.app</code></p>
                <p>如果你在一个中间件模块中暴露了接口，并且挂载到主节点上，那么这个中间件就能通过req.app获得express实例</p>
                <p>For example:</p>
                <pre><code class="language-js">//index.js
app.get("/viewdirectory", require("./mymiddleware.js"))
</code></pre>
                <pre><code class="language-js">//mymiddleware.js
module.exports = function (req, res) {
  res.send("The views directory is " + req.app.get("views"));
});
</code></pre>
            </section>
            <section>
                <h3 id="req.baseUrl">req.baseUrl</h3>
                <p>The URL path on which a router instance was mounted. For example:</p>
                <p>req.baseUrl返回的是路由挂载的路径，比如：</p>
                <pre><code class="language-js">var greet = express.Router();

greet.get('/jp', function (req, res) {
  console.log(req.baseUrl); // /greet
  res.send('Konichiwa!');
});

app.use('/greet', greet); // load the router on '/greet'
</code></pre>
                <p>Even if you use a path pattern or a set of path patterns to load the router, the <code>baseUrl</code> property returns the matched string, not the pattern(s). In the following example, the <code>greet</code> router is loaded on two path patterns.</p>
                <p>
                    即使你使用路径匹配或者路径匹配集合来挂载路由，baseURL属性也会返回实际匹配的字符串，而不是匹配规则，在下面的实例中，greet路由能被两条路径规则匹配到，
                </p>
                <pre><code class="language-js">app.use(['/gre+t', '/hel{2}o'], greet); // load the router on '/gre+t' and '/hel{2}o'
</code></pre>
                <p>When a request is made to <code>/greet/jp</code>, <code>req.baseUrl</code> is “/greet”. When a request is made to <code>/hello/jp</code>, <code>req.baseUrl</code> is “/hello”.</p>
                <p>当请求来自/greet/jp,req.baseUrl是/greet，当请求来自/hello/jp，req.baseUrl是/hello</p>
                <p><code>req.baseUrl</code> is similar to the <a href="#app.mountpath">mountpath</a> property of the <code>app</code> object, except <code>app.mountpath</code> returns the matched path pattern(s).</p>
            </section>
            <section>
                <h3 id="req.body">req.body</h3>
                <p>Contains key-value pairs of data submitted in the request body. By default, it is <code>undefined</code>, and is populated when you use body-parsing middleware such as <a href="https://www.npmjs.org/package/body-parser">body-parser</a> and <a href="https://www.npmjs.org/package/multer">multer</a>.</p>
                <p>
                    从请求体中提交来的键值对数据，默认是undefined，当你用一些解析中间件时它会被赋值
                </p>
                <p>This example shows how to use body-parsing middleware to populate <code>req.body</code>.</p>
                <p>这个例子展示了如何用body-parsing来赋值req.body</p>
                <pre><code class="language-js">var app = require('express')();
var bodyParser = require('body-parser');
var multer = require('multer'); 

app.use(bodyParser.json()); // for parsing application/json
app.use(bodyParser.urlencoded({ extended: true })); // for parsing application/x-www-form-urlencoded
app.use(multer()); // for parsing multipart/form-data

app.post('/', function (req, res) {
  console.log(req.body);
  res.json(req.body);
})
</code></pre>
            </section>
            <section>
                <h3 id="req.cookies">req.cookies</h3>
                <p>When using <a href="https://www.npmjs.com/package/cookie-parser">cookie-parser</a> middleware, this property is an object that contains cookies sent by the request. If the request contains no cookies, it defaults to <code>{}</code>.</p>
                <p>当使用cookie-parser中间件时，这个属性就会包含一个从请求发来的cookies对象，如果请求不含cookies，那么属性值就是一个空的对象</p>
                <pre><code class="language-js">// Cookie: name=tj
req.cookies.name
// =&gt; "tj"
</code></pre>
                <p>查看更多信息 <a href="https://github.com/expressjs/cookie-parser">cookie-parser</a>.</p>
            </section>
            <section>
                <h3 id="req.fresh">req.fresh</h3>
                <p>Indicates whether the request is “fresh.” It is the opposite of <code>req.stale</code>.</p>
                <p>用来显示请求是否fresh，他的反面则是req.stalle</p>
                <p>It is true if the <code>cache-control</code> request header doesn’t have a <code>no-cache</code> directive and any of the following is true:</p>
                <p>
                    如果请求头不存在任何no-cache指令且任何下面所列为真值时，它的值为真。
                </p>
                <ul>
                    <li>The <code>if-modified-since</code> request header is specified and <code>last-modified</code> request header is equal to or eariler than the <code>modified</code> response header.</li>
                    <li>The <code>if-none-match</code> request header is <code>*</code>.</li>
                    <li>The <code>if-none-match</code> request header, after being parsed into its directives, does not match the <code>etag</code> response header.</li>
                </ul>
                <pre><code class="language-js">req.fresh
// =&gt; true
</code></pre>
                <p>For more information, issues, or concerns, see <a href="https://github.com/jshttp/fresh">fresh</a>.</p>
            </section>
            <section>
                <h3 id="req.hostname">req.hostname</h3>
                <p>Contains the hostname from the “Host” HTTP header.</p>
                <p>从HTTP头部获得主机名</p>
                <pre><code class="language-js">// Host: "example.com:3000"
req.hostname
// =&gt; "example.com"
</code></pre>
            </section>
            <section>
                <h3 id="req.ip">req.ip</h3>
                <p>The remote IP address of the request.</p>
                <p>请求的远程ip地址</p>
                <p>If the <code>trust proxy</code> is setting enabled, it is the upstream address; see <a href="/guide/behind-proxies.html">Express behind proxies</a> for more information.</p>
                <p>如果代理服务器可用，显示的是上层地址</p>
                <pre><code class="language-js">req.ip
// =&gt; "127.0.0.1"
</code></pre>
            </section>
            <section>
                <h3 id="req.ips">req.ips</h3>
                <p>When the <code>trust proxy</code> setting is <code>true</code>, this property contains an array of IP addresses specified in the “X-Forwarded-For” request header. Otherwise, it contains an empty array.</p>
                <p>当代理服务器设置为true时，这个属性就会包含一个ip地址数组，否则则是一个空数组</p>
                <p>For example, if “X-Forwarded-For” is “client, proxy1, proxy2”, <code>req.ips</code> would be
                    <code>["client", "proxy1", "proxy2"]</code>, where “proxy2” is the furthest downstream.</p>
                <p>更多信息请查看<a href="#app.set">app.set</a>.</p>
            </section>
            <section>
                <h3 id="req.originalUrl">req.originalUrl</h3>
                <div class="doc-box doc-notice">
                    <p><code>req.url</code> is not a native Express property, it is inherited from Node’s <a href="https://nodejs.org/api/http.html#http_message_url">http module</a>.</p>
                    <p>req.url不是原生的express属性，而是从Noded http模块继承而来</p>
                </div>
                <p>This property is much like <code>req.url</code>; however, it retains the original request URL, allowing you to rewrite <code>req.url</code> freely for internal routing purposes. For example, the “mounting” feature of <a href="#app.use">app.use()</a> will rewrite <code>req.url</code> to strip the mount point.</p>
                <p>这个属性更像req.url，但是他包含了原始的请求地址，允许你重写req.url重定向以便内部路由，比如，app.use()的 mounting特性会重写req.url</p>
                <pre><code class="language-js">// GET /search?q=something
req.originalUrl
// =&gt; "/search?q=something"
</code></pre>
            </section>
            <section>
                <h3 id="req.params">req.params</h3>
                <p>An object containing properties mapped to the named route “parameters”. For example, if you have the route <code>/user/:name</code>, then the “name” property is available as <code>req.params.name</code>. This object defaults to <code>{}</code>.</p>
                <p>一个包含了路由参数的对象，比如，你的路由规则是/user/:name，然后req.params.name就可以得到：name的值，这个对象默认值是一个空的对象</p>
                <pre><code class="language-js">// GET /user/tj
req.params.name
// =&gt; "tj"
</code></pre>
                <p>When you use a regular expression for the route definition, capture groups are provided in the array using <code>req.params[n]</code>, where <code>n</code> is the n<sup>th</sup> capture group. This rule is applied to unnamed wild card matches with string routes such as <code>/file/*</code>:</p>
                <p>当你使用正则表达式定义的路由时，req.params[n]中的n代表的就是正则捕获组的序号，这个规则也可用于像/file/*的字符串路径</p>
                <pre><code class="language-js">// GET /file/javascripts/jquery.js
req.params[0]
// =&gt; "javascripts/jquery.js"
</code></pre>
            </section>
            <section>
                <h3 id="req.path">req.path</h3>
                <p>Contains the path part of the request URL.</p>
                <p>包含一部分请求路径</p>
                <pre><code class="language-js">// example.com/users?sort=desc
req.path
// =&gt; "/users"
</code></pre>
                <div class="doc-box doc-info">
                    <p>When called from a middleware, the mount point is not included in <code>req.path</code>. Look up <a href="/4x/api.html#app.use">app.use()</a> for more details.</p>
                    <p>当在中间件中使用时，挂载点不会包括在内，查看更多信息<a href="/4x/api.html#app.use">app.use()</a> </p>
                </div>
            </section>
            <section>
                <h3 id="req.protocol">req.protocol</h3>
                <p>The request protocol string, “http” or “https” when requested with TLS. When the “trust proxy” <a href="/4x/api.html#trust.proxy.options.table">setting</a> trusts the socket address, the value of the “X-Forwarded-Proto” header (“http” or “https”) field will be trusted and used if present.</p>
                <p>获取http的类型，一般是http，当使用加密的安全协议时是https，当端口地址添加进了白名单时，X-Forwarded-Proto头部协议会被信任并且使用</p>
                <pre><code class="language-js">req.protocol
// =&gt; "http"
</code></pre>
            </section>
            <section>
                <h3 id="req.query">req.query</h3>
                <p>An object containing a property for each query string parameter in the route. If there is no query string, it is the empty object, <code>{}</code>.</p>
                <p>一个包含了路由路径中的查询参数对象，如果没有查询参数，则是一个空的对象</p>
                <pre><code class="language-js">// GET /search?q=tobi+ferret
req.query.q
// =&gt; "tobi ferret"

// GET /shoes?order=desc&amp;shoe[color]=blue&amp;shoe[type]=converse
req.query.order
// =&gt; "desc"

req.query.shoe.color
// =&gt; "blue"

req.query.shoe.type
// =&gt; "converse"
</code></pre>
            </section>
            <section>
                <h3 id="req.route">req.route</h3>
                <p>The currently-matched route, a string. For example:</p>
                <p>当前匹配路由信息</p>
                <pre><code class="language-js">app.get('/user/:id?', function userIdHandler(req, res) {
  console.log(req.route);
  res.send('GET');
})
</code></pre>
                <p>Example output from the previous snippet:</p>
                <p>上一个示例的输出结果</p>
                <pre><code class="language-js">{ path: '/user/:id?',
  stack:
   [ { handle: [Function: userIdHandler],
       name: 'userIdHandler',
       params: undefined,
       path: undefined,
       keys: [],
       regexp: /^\/?$/i,
       method: 'get' } ],
  methods: { get: true } }
</code></pre>
            </section>
            <section>
                <h3 id="req.secure">req.secure</h3>
                <p>A Boolean that is true if a TLS connection is established. Equivalent to:</p>
                <p>假如使用的加密的https访问，则值为真，和下面的示例等价</p>
                <pre><code class="language-js">'https' == req.protocol;
</code></pre>
            </section>
            <section>
                <h3 id="req.signedCookies">req.signedCookies</h3>
                <p>When using <a href="https://www.npmjs.com/package/cookie-parser">cookie-parser</a> middleware, this property contains signed cookies sent by the request, unsigned and ready for use. Signed cookies reside in a different object to show developer intent; otherwise, a malicious attack could be placed on
                    <code>req.cookie</code> values (which are easy to spoof). Note that signing a cookie does not make it “hidden” or encrypted; but simply prevents tampering (because the secret used to sign is private). If no signed cookies are sent, the property defaults to <code>{}</code>.</p>
                <p>当使用cookie-parser中间件时，这个属性提取了来自请求的已签名cookies信息的未签名部分，并且可以直接使用，签名的信息留在其他对象内，否则，在来自客户端的cookies中可能会有恶意的攻击（cookies炒鸡容易更改），对cookies进行签名不意味着隐藏cookies或者加密它，只是简单的防篡改(因为用来签名的密钥是私有的)，如果没有签名的cookies从客户端发送过来，属性默认是空对象。</p>
                <pre><code class="language-js">// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
req.signedCookies.user
// =&gt; "tobi"
</code></pre>
                <p>更多信息请查看 <a href="https://github.com/expressjs/cookie-parser">cookie-parser</a>.</p>
            </section>
            <section>
                <h3 id="req.stale">req.stale</h3>
                <p>Indicates whether the request is “stale,” and is the opposite of <code>req.fresh</code>. For more information, see <a href="#req.fresh">req.fresh</a>.</p>
                <p>用来描述请求是否是'旧的'，相对的属性就是req.fresh，更多信息请查看<a href="#req.fresh">req.fresh</a></p>
                <pre><code class="language-js">req.stale
// =&gt; true
</code></pre>
            </section>
            <section>
                <h3 id="req.subdomains">req.subdomains</h3>
                <p>An array of subdomains in the domain name of the request.</p>
                <p>一个包含了请求域名子域名的数组</p>
                <pre><code class="language-js">// Host: "tobi.ferrets.example.com"
req.subdomains
// =&gt; ["ferrets", "tobi"]
</code></pre>
            </section>
            <section>
                <h3 id="req.xhr">req.xhr</h3>
                <p>A Boolean value that is <code>true</code> if the request’s “X-Requested-With” header field is “XMLHttpRequest”, indicating that the request was issued by a client library such as jQuery.</p>
                <p>一个布尔值，如果X-Requested-With头部信息是XMLHttpRequest，则值为真。值为真，则显示这个请求是由类似客户端库jquery发送的</p>
                <pre><code class="language-js">req.xhr
// =&gt; true
</code></pre>
            </section>
            <h3 id="req.methods">Methods</h3>
            <section>
                <h3 id="req.accepts">req.accepts(types)</h3>
                <p>Checks if the specified content types are acceptable, based on the request’s <code>Accept</code> HTTP header field. The method returns the best match, or if none of the specified content types is acceptable, returns undefined (in which case, the application should respond with <code>406 "Not Acceptable"</code>).</p>
                <p>基于请求的头部信息检测指定的内容是否允许请求，这个方法返回最佳匹配的值，如果指定内容不被允许请求，则返回undefined（这个情况下，应该响应一个406请求，不被允许的请求）</p>
                <p>The <code>type</code> value may be a single MIME type string (such as “application/json”), an extension name such as “json”, a comma-delimited list, or an array. For a list or array, the method returns the <em>best</em> match (if any).</p>
                <p>这个值可能是一个 MIME类型的字符串（类似application/json），一个扩展名比如json,一个逗号分隔的列表或者一个数组，对于一个列表或者数组来说，这个方法总是返回存在的最佳匹配值</p>
                <pre><code class="language-js">// Accept: text/html
req.accepts('html');
// =&gt; "html"

// Accept: text/*, application/json
req.accepts('html');
// =&gt; "html"
req.accepts('text/html');
// =&gt; "text/html"
req.accepts(['json', 'text']);
// =&gt; "json"
req.accepts('application/json');
// =&gt; "application/json"

// Accept: text/*, application/json
req.accepts('image/png');
req.accepts('png');
// =&gt; undefined

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json']);
// =&gt; "json"
</code></pre>
                <p>更多信息请查看<a href="https://github.com/expressjs/accepts">accepts</a>.</p>
            </section>
            <section>
                <h3 id="req.acceptsCharsets">req.acceptsCharsets(charset [, ...])</h3>
                <p>Returns the first accepted charset of the specified character sets, based on the request’s <code>Accept-Charset</code> HTTP header field. If none of the specified charsets is accepted, returns <code>false</code>.</p>
                <p>返回基于请求头Accept-Charset 头部信息的可接受字符编码，如果没有任何可接受的编码，返回false</p>
                <p>更多信息请查看 <a href="https://github.com/expressjs/accepts">accepts</a>.</p>
            </section>
            <section>
                <h3 id="req.acceptsEncodings">req.acceptsEncodings(encoding [, ...])</h3>
                <p>Returns the first accepted encoding of the specified encodings, based on the request’s <code>Accept-Encoding</code> HTTP header field. If none of the specified encodings is accepted, returns <code>false</code>.</p>
                <p>返回基于请求Accept-Encoding的头部信息的可接受编码类型，如果没有任何可以接受的编码类型，返回false</p>
                <p>更多信息 <a href="https://github.com/expressjs/accepts">accepts</a>.</p>
            </section>
            <section>
                <h3 id="req.acceptsLanguages">req.acceptsLanguages(lang [, ...])</h3>
                <p>Returns the first accepted language of the specified languages, based on the request’s <code>Accept-Language</code> HTTP header field. If none of the specified languages is accepted, returns <code>false</code>.</p>
                <p>返回基于请求Accept-Language头部信息的可接受语言，如果没有任何可接受的语言，返回false</p>
                <p>更多信息请查看 <a href="https://github.com/expressjs/accepts">accepts</a>.</p>
            </section>
            <section>
                <h3 id="req.get">req.get(field)</h3>
                <p>Returns the specified HTTP request header field (case-insensitive match). The <code>Referrer</code> and <code>Referer</code> fields are interchangeable.</p>
                <p>返回指定的请求头信息， Referrer 和 Referer fields没有什么区别</p>
                <pre><code class="language-js">req.get('Content-Type');
// =&gt; "text/plain"

req.get('content-type');
// =&gt; "text/plain"

req.get('Something');
// =&gt; undefined
</code></pre>
                <p>也可以看做 <code>req.header(field)</code>的别名.</p>
            </section>
            <section>
                <h3 id="req.is">req.is(type)</h3>
                <p>Returns <code>true</code> if the incoming request’s “Content-Type” HTTP header field matches the MIME type specified by the <code>type</code> parameter. Returns <code>false</code> otherwise.</p>
                <p>如果指定的信息和来自请求的头部信息能成功匹配上则返回true，否则返回false.</p>
                <pre><code class="language-js">// With Content-Type: text/html; charset=utf-8
req.is('html');
req.is('text/html');
req.is('text/*');
// =&gt; true

// When Content-Type is application/json
req.is('json');
req.is('application/json');
req.is('application/*');
// =&gt; true

req.is('html');
// =&gt; false
</code></pre>
                <p>更多信息请查看 <a href="https://github.com/expressjs/type-is">type-is</a>.</p>
            </section>
            <section>
                <h3 id="req.param">req.param(name [, defaultValue])</h3>
                <div class="doc-box doc-warn">
                    <p>Deprecated. Use either <code>req.params</code>, <code>req.body</code> or <code>req.query</code>, as applicable.</p>
                    <p>不推荐使用，建议使用req.params ，req.body ，req.query</p>
                </div>
                <p>返回存在的name值.</p>
                <pre><code class="language-js">// ?name=tobi
req.param('name')
// =&gt; "tobi"

// POST name=tobi
req.param('name')
// =&gt; "tobi"

// /user/tobi for /user/:name 
req.param('name')
// =&gt; "tobi"
</code></pre>
                <p>建议查看下列方法是如何使用的:</p>
                <ul>
                    <li><code>req.params</code></li>
                    <li><code>req.body</code></li>
                    <li><code>req.query</code></li>
                </ul>
                <p>Optionally, you can specify <code>defaultValue</code> to set a default value if the parameter is not found in any of the request objects.</p>
                <p>如果参数中没有你想查询的值，你也可以设置一个默认值。</p>
                <div class="doc-box doc-warn">
                    <p>Direct access to <code>req.body</code>, <code>req.params</code>, and <code>req.query</code> should be favoured for clarity - unless you truly accept input from each object.</p>
                    <p>Body-parsing middleware must be loaded for <code>req.param()</code> to work predictably. Refer <a href="#req.body">req.body</a> for details.</p>
                    <p>直接使用<code>req.body</code>, <code>req.params</code>, and <code>req.query</code>会使得代码逻辑更加清晰，除非你不混用参数，Body-parsing中间件会为了req.param()预先加载</p>
                </div>
            </section>
            <p>
                <a id="res" class="h2"></a>
            </p>
            <h2>Response</h2>
            <p>The <code>res</code> object represents the HTTP response that an Express app sends when it gets an HTTP request.</p>
            <p>res通常是指express应用在接收http请求时的响应response</p>
            <p>In this documentation and by convention, the object is always referred to as <code>res</code> (and the HTTP request is <code>req</code>) but its actual name is determined by the parameters to the callback function in which you’re working.</p>
            <p>为了方便，通常使用res简写，但是这取决于你在回调函数中使用的形参名称。</p>
            <p>例如:</p>
            <pre><code class="language-js">app.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});
</code></pre>
            <p>你也可以这样使用:</p>
            <pre><code class="language-js">app.get('/user/:id', function(request, response){
  response.send('user ' + request.params.id);
});
</code></pre>
            <h3 id="res.properties">Properties</h3>
            <section>
                <h3 id="res.app">res.app</h3>
                <p>This property holds a reference to the instance of the express application that is using the middleware.</p>
                <p>这属性会指向当前使用此中间层的express应用</p>
                <p><code>res.app</code> 用法和 <a href="#req.app">req.app</a> 完全一致.</p>
            </section>
            <section>
                <h3 id="res.headersSent">res.headersSent</h3>
                <p>Boolean property that indicates if the app sent HTTP headers for the response.</p>
                <p>显示应用是否发送了http头部的布尔值</p>
                <pre><code class="language-js">app.get('/', function (req, res) {
  console.log(res.headersSent); // false
  res.send('OK');
  console.log(res.headersSent); // true
})
</code></pre>
            </section>
            <section>
                <h3 id="res.locals">res.locals</h3>
                <p>An object that contains response local variables scoped to the request, and therefore available only to the view(s) rendered during that request / response cycle (if any). Otherwise, this property is identical to <a href="#app.locals">app.locals</a>.</p>
                <p>一个包含了响应请求的局部变量，因此只在 请求-响应 的生命周期内渲染视图可用，其他的用法和<a href="#app.locals">app.locals</a>基本一致</p>
                <p>This property is useful for exposing request-level information such as the request path name, authenticated user, user settings, and so on.</p>
                <p>这个属性可以用来暴露请求的相关信息，比如请求路径名称，用户认证，用户设置....</p>
                <pre><code class="language-js">app.use(function(req, res, next){
  res.locals.user = req.user;
  res.locals.authenticated = ! req.user.anonymous;
  next();
});
</code></pre>
            </section>
            <h3 id="res.methods">Methods</h3>
            <section>
                <h3 id="res.append">res.append(field [, value])</h3>
                <div class="doc-box doc-info">
                    <p><code>res.append()</code> is supported by Express v4.11.0+
                        <br>只支持Express v4.11.0+ </p>
                </div>
                <p>Appends the specified <code>value</code> to the HTTP response header <code>field</code>. If the header is not already set, it creates the header with the specified value. The <code>value</code> parameter can be a string or an array.</p>
                <p>添指定的响应头信息，如果响应头未设置，他会创建响应头，这个值可以是一个字符串或者数组</p>
                <p>Note: calling <code>res.set()</code> after <code>res.append()</code> will reset the previously-set header value.</p>
                <p>如果在在res.append()后使用res.set()，会覆盖先前的值</p>
                <pre><code class="language-js">res.append('Link', ['&lt;http://localhost/&gt;', '&lt;http://localhost:3000/&gt;']);
res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');
res.append('Warning', '199 Miscellaneous warning');
</code></pre>
            </section>
            <section>
                <h3 id="res.attachment">res.attachment([filename])</h3>
                <p>Sets the HTTP response <code>Content-Disposition</code> header field to “attachment”. If a <code>filename</code> is given, then it sets the Content-Type based on the extension name via <code>res.type()</code>, and sets the <code>Content-Disposition</code> “filename=” parameter.</p>
                <p>设置http响应 Content-Disposition头部信息，如果设置了一个文件名，那么就是基于文件名的扩展名设置Content-Type ，并且设置Content-Disposition的属性</p>
                <pre><code class="language-js">res.attachment();
// Content-Disposition: attachment

res.attachment('path/to/logo.png');
// Content-Disposition: attachment; filename="logo.png"
// Content-Type: image/png
</code></pre>
            </section>
            <section>
                <h3 id="res.cookie">res.cookie(name, value [, options])</h3>
                <p>Sets cookie <code>name</code> to <code>value</code>. The <code>value</code> parameter may be a string or object converted to JSON.</p>
                <p>设置cookie中name的值为value，value参数可能是字符串或者一个转换后的json对象</p>
                <p>The <code>options</code> parameter is an object that can have the following properties.</p>
                <p>可选项是由下面属性组成的对象</p>
                <table>
                    <thead>
                        <tr>
                            <th>Property</th>
                            <th>Type</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>domain</code></td>
                            <td>String</td>
                            <td>Domain name for the cookie. Defaults to the domain name of the app.</td>
                        </tr>
                        <tr>
                            <td><code>expires</code></td>
                            <td>Date</td>
                            <td>Expiry date of the cookie in GMT. If not specified or set to 0, creates a session cookie.</td>
                        </tr>
                        <tr>
                            <td><code>httpOnly</code></td>
                            <td>Boolean</td>
                            <td>Flags the cookie to be accessible only by the web server.</td>
                        </tr>
                        <tr>
                            <td><code>maxAge</code></td>
                            <td>String</td>
                            <td>Convenient option for setting the expiry time relative to the current time in milliseconds.</td>
                        </tr>
                        <tr>
                            <td><code>path</code></td>
                            <td>String</td>
                            <td>Path for the cookie. Defaults to “/”.</td>
                        </tr>
                        <tr>
                            <td><code>secure</code></td>
                            <td>Boolean</td>
                            <td>Marks the cookie to be used with HTTPS only.</td>
                        </tr>
                        <tr>
                            <td><code>signed</code></td>
                            <td>Boolean</td>
                            <td>Indicates if the cookie should be signed.</td>
                        </tr>
                    </tbody>
                </table>
                <div class="doc-box doc-notice">
                    <p>All <code>res.cookie()</code> does is set the HTTP <code>Set-Cookie</code> header with the options provided. Any option not specified defaults to the value stated in <a href="http://tools.ietf.org/html/rfc6265">RFC 6265</a>.</p>
                </div>
                <p>For example:</p>
                <pre><code class="language-js">res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true });
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
</code></pre>
                <p>The <code>maxAge</code> option is a convenience option for setting “expires” relative to the current time in milliseconds. The following is equivalent to the second example above.</p>
                <p>maxAge选项能更方便的设置cookies的过期时间，下面个例子和上面的例子作用相同</p>
                <pre><code class="language-js">res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
</code></pre>
                <p>You can pass an object as the <code>value</code> parameter; it is then serialized as JSON and parsed by <code>bodyParser()</code> middleware.</p>
                <p>你能传一个对象作为value的参数，bodyParser()能够作为json对象序列化和解析它</p>
                <pre><code class="language-js">res.cookie('cart', { items: [1,2,3] });
res.cookie('cart', { items: [1,2,3] }, { maxAge: 900000 });
</code></pre>
                <p>When using <a href="https://www.npmjs.com/package/cookie-parser">cookie-parser</a> middleware, this method also supports signed cookies. Simply include the <code>signed</code> option set to <code>true</code>. Then <code>res.cookie()</code> will use the secret passed to <code>cookieParser(secret)</code> to sign the value.</p>
                <p>当使用<a href="https://www.npmjs.com/package/cookie-parser">cookie-parser</a>中间件时，这个方法也支持签名cookies,只需要在设置里设置signed为true，然后res.cookie()就会使用密码签名这个值</p>
                <pre><code class="language-js">res.cookie('name', 'tobi', { signed: true });
</code></pre>
                <p>Later you may access this value through the <a href="#req.signedCookies">req.signedCookie</a> object.</p>
                <p>之后你就可以通过<a href="#req.signedCookies">req.signedCookie</a>获取到这个值</p>
            </section>
            <section>
                <h3 id="res.clearCookie">res.clearCookie(name [, options])</h3>
                <p>清空 <code>name</code>的值. 更多信息请查看<a href="#res.cookie">res.cookie()</a>.</p>
                <pre><code class="language-js">res.cookie('name', 'tobi', { path: '/admin' });
res.clearCookie('name', { path: '/admin' });
</code></pre>
            </section>
            <section>
                <h3 id="res.download">res.download(path [, filename] [, fn])</h3>
                <p>Transfers the file at <code>path</code> as an “attachment”. Typically, browsers will prompt the user for download. By default, the <code>Content-Disposition</code> header “filename=” parameter is <code>path</code> (this typically appears in the brower dialog). Override this default with the <code>filename</code> parameter.</p>
                <p>设置path的值为‘attachment’的属性，通常浏览器会允许用户下载。默认情况下下载的文件名会被浏览器弹出的会话框修改</p>
                <p>When an error ocurrs or transfer is complete, the method calls the optional callback function <code>fn</code>. This method uses <a href="#res.sendFile">res.sendFile()</a> to transfer the file.</p>
                <p>当发生错误或者传输完成时，这个方法会调用选项里的回调函数，这个方法使用的是<a href="#res.sendFile">res.sendFile()</a>来传输文件</p>
                <pre><code class="language-js">res.download('/report-12345.pdf');

res.download('/report-12345.pdf', 'report.pdf');

res.download('/report-12345.pdf', 'report.pdf', function(err){
  if (err) {
    // Handle error, but keep in mind the response may be partially-sent
    // so check res.headersSent
  } else {
    // decrement a download credit, etc.
  }
});
</code></pre>
            </section>
            <section>
                <h3 id="res.end">res.end([data] [, encoding])</h3>
                <p>Ends the response process. This method actually comes from Node core, specifically the <a href="https://nodejs.org/api/http.html#http_response_end_data_encoding_callback">response.end() method of  http.ServerResponse</a>.</p>
                <p>结束响应进程，这个方法来自Node的核心模块。<a href="https://nodejs.org/api/http.html#http_response_end_data_encoding_callback">response.end() method of  http.ServerResponse</a></p>
                <p>Use to quickly end the response without any data. If you need to respond with data, instead use methods such as <a href="#res.send">res.send()</a> and <a href="#res.json">res.json()</a>.</p>
                <p>不填入任何参数可以结束响应，如果你想响应一些数据，你可以用<a href="#res.send">res.send()</a> 和<a href="#res.json">res.json()</a></p>
                <pre><code class="language-js">res.end();
res.status(404).end();
</code></pre>
            </section>
            <section>
                <h3 id="res.format">res.format(object)</h3>
                <p>Performs content-negotiation on the <code>Accept</code> HTTP header on the request object, when present. It uses <a href="#req.accepts">req.accepts()</a> to select a handler for the request, based on the acceptable types ordered by their quality values. If the header is not specified, the first callback is invoked. When no match is found, the server responds with 406 “Not Acceptable”, or invokes the <code>default</code> callback.</p>
                <p>根据请求的的content-negotiation信息给予不同的响应，会根据<a href="#req.accepts">req.accepts()</a>列表选择一个对应的响应规则，如果没有指定的响应头，第一个响应规则会被调用，如果没有匹配的请求头信息，那么则会返回406 Not Acceptable，或者调用默认回调</p>
                <p>The <code>Content-Type</code> response header is set when a callback is selected. However, you may alter this within the callback using methods such as <code>res.set()</code> or <code>res.type()</code>.</p>
                <p>响应的Content-Type头部信息在回调被选中的时候就设置了，但你也可以在这个回调内使用<code>res.set()</code> 或<code>res.type()</code>来修改</p>
                <p>The following example would respond with <code>{ "message": "hey" }</code> when the <code>Accept</code> header field is set to “application/json” or “*/json” (however if it is “*/*”, then the response will be “hey”).</p>
                <p>如果可接受的响应头被设置成 “application/json”或者“*/json”下面的例子会返回 { "message": "hey" }，如果是“*/*”，响应的则是第一个类型“hey”</p>
                <pre><code class="language-js">res.format({
  'text/plain': function(){
    res.send('hey');
  },

  'text/html': function(){
    res.send('&lt;p&gt;hey&lt;/p&gt;');
  },

  'application/json': function(){
    res.send({ message: 'hey' });
  },

  'default': function() {
    // log the request and respond with 406
    res.status(406).send('Not Acceptable');
  }
});
</code></pre>
                <p>In addition to canonicalized MIME types, you may also use extension names mapped to these types for a slightly less verbose implementation:</p>
                <p>除了规范化的MIME类型，你也可以用简单的扩展名来替代复杂的名称</p>
                <pre><code class="language-js">res.format({
  text: function(){
    res.send('hey');
  },

  html: function(){
    res.send('&lt;p&gt;hey&lt;/p&gt;');
  },

  json: function(){
    res.send({ message: 'hey' });
  }
});
</code></pre>
            </section>
            <section>
                <h3 id="res.get">res.get(field)</h3>
                <p>Returns the HTTP response header specified by <code>field</code>. The match is case-insensitive.</p>
                <p>返回指定的HTTP响应头信息，不区分大小。</p>
                <pre><code class="language-js">res.get('Content-Type');
// =&gt; "text/plain"
</code></pre>
            </section>
            <section>
                <h3 id="res.json">res.json([body])</h3>
                <p>Sends a JSON response. This method is identical to <code>res.send()</code> with an object or array as the parameter. However, you can use it to convert other values to JSON, such as <code>null</code>, and <code>undefined</code>. (although these are technically not valid JSON).</p>
                <p>响应一个json数据，这个方法和res.send()在发送一个对象或者数组时完全相同，但你可以用这个方法来把其他值转换成json数据，比如null,undefined（尽管他们实际上不是合法的json数据）。</p>
                <pre><code class="language-js">res.json(null)
res.json({ user: 'tobi' })
res.status(500).json({ error: 'message' })
</code></pre>
            </section>
            <section>
                <h3 id="res.jsonp">res.jsonp([body])</h3>
                <p>Sends a JSON response with JSONP support. This method is identical to <code>res.json()</code>, except that it opts-in to JSONP callback support.</p>
                <p>用jsonp的方式发送一个json数据，这个方法等同于 res.json()，除了支持一个回调名称</p>
                <pre><code class="language-js">res.jsonp(null)
// =&gt; null

res.jsonp({ user: 'tobi' })
// =&gt; { "user": "tobi" }

res.status(500).jsonp({ error: 'message' })
// =&gt; { "error": "message" }
</code></pre>
                <p>By default, the JSONP callback name is simply <code>callback</code>. Override this with the
                    <a href="#app.settings.table">jsonp callback name</a> setting.</p>
                <p>默认情况下，jsonp的回调是由请求指定，也可以由<a href="#app.settings.table">jsonp callback name</a> 重新设置</p>
                <p>下面是一些jsonp的简单示例:</p>
                <pre><code class="language-js">// ?callback=foo
res.jsonp({ user: 'tobi' })
// =&gt; foo({ "user": "tobi" })

app.set('jsonp callback name', 'cb');

// ?cb=foo
res.status(500).jsonp({ error: 'message' })
// =&gt; foo({ "error": "message" })
</code></pre>
            </section>
            <section>
                <h3 id="res.links">res.links(links)</h3>
                <p>Joins the <code>links</code> provided as properties of the parameter to populate the response’s
                    <code>Link</code> HTTP header field.</p>
                <p>给http头字段link属性加入一些值</p>
                <pre><code class="language-js">res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
});
</code></pre>
                <p>yields:</p>
                <pre><code class="language-js">Link: &lt;http://api.example.com/users?page=2&gt;; rel="next", 
      &lt;http://api.example.com/users?page=5&gt;; rel="last"
</code></pre>
            </section>
            <section>
                <h3 id="res.location">res.location(path)</h3>
                <p>Sets the response <code>Location</code> HTTP header to the specified <code>path</code> parameter.
                </p>
                <p>给指定的路径设置响应的Location HTTP 头</p>
                <pre><code class="language-js">res.location('/foo/bar');
res.location('http://example.com');
res.location('back');
</code></pre>
                <p>A <code>path</code> value of “back” has a special meaning, it refers to the URL specified in the <code>Referer</code> header of the request. If the <code>Referer</code> header was not specified, it refers to “/”.</p>
                <p> 把path的值设置成'back'有特殊的意思，它会设置为请求指定的引用头，如果引用头未指定，它会指向'/'</p>
                <div class="doc-box doc-warn">
                    <p>Express passes the specified URL string as-is to the browser in the <code>Location</code> header, without any validation or manipulation, except in case of <code>back</code>.</p>
                    <p>Browsers take the responsibility of deriving the intended URL from the current URL or the referring URL, and the URL specified in the <code>Location</code> header; and redirect the user accordingly.</p>
                </div>
            </section>
            <section>
                <h3 id="res.redirect">res.redirect([status,] path)</h3>
                <p>Redirects to the URL dervied from the specified <code>path</code>, with specified
                    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP status code</a> <code>status</code>. If you don’t specify <code>status</code>, the status code defaults to “302 “Found”.</p>
                <p>带上一个状态码重定向到指定的地址，如果未指定，默认是302</p>
                <pre><code class="language-js">res.redirect('/foo/bar');
res.redirect('http://example.com');
res.redirect(301, 'http://example.com');
res.redirect('../login');
</code></pre>
                <p>Redirects can be a fully-qualified URL for redirecting to a different site:</p>
                <p>重定向也可以是一个完整的地址用来定向到其他网站</p>
                <pre><code class="language-js">res.redirect('http://google.com');
</code></pre>
                <p>Redirects can be relative to the root of the host name. For example, if the application is on <code>http://example.com/admin/post/new</code>, the following would redirect to the URL <code>http://example.com/admin</code>:</p>
                <p>重定向是基于主机名进行定向的，比如，应用在http://example.com/admin/post/new进行重定向，下面的定向会重定向到http://example.com/admin</p>
                <pre><code class="language-js">res.redirect('/admin');
</code></pre>
                <p>Redirects can be relative to the current URL. For example, from <code>http://example.com/blog/admin/</code> (notice the trailing slash), the following would redirect to the URL <code>http://example.com/blog/admin/post/new</code>.</p>
                <p>定向也可以相对于当前网址进行，从http://example.com/blog/admin/ （注意斜杠）下面的操作会定向到http://example.com/blog/admin/post/new</p>
                <pre><code class="language-js">res.redirect('post/new');
</code></pre>
                <p>Redirecting to <code>post/new</code> from <code>http://example.com/blog/admin</code> (no trailing slash), will redirect to <code>http://example.com/blog/post/new</code>.</p>
                <p>从http://example.com/blog/admin定向到post/new实际上会定向到http://example.com/blog/post/new</p>
                <p>If you found the above behavior confusing, think of path segments as directories (with trailing slashes) and files, it will start to make sense.</p>
                <p>如果你觉得上面的行为让你很迷惑，你可以想象一下文件夹路径和索引</p>
                <p>下面的操作能让你从 http://example.com/admin/post/new, 定向到 http//example.com/admin/post:
                </p>
                <pre><code class="language-js">res.redirect('..');
</code></pre>
                <p>A <code>back</code> redirection redirects the request back to the <a href="http://en.wikipedia.org/wiki/HTTP_referer">referer</a>, defaulting to <code>/</code> when the referer is missing.</p>
                <p>'back'能重定向到来源页，默认是'/'</p>
                <pre><code class="language-js">res.redirect('back');    
</code></pre>
            </section>
            <section>
                <h3 id="res.render">res.render(view [, locals] [, callback])</h3>
                <p>Renders a <code>view</code> and sends the rendered HTML string to the client. Optional parameters:</p>
                <p>渲染一个视图并且把渲染后的视图发送给客户端，可选的参数</p>
                <ul>
                    <li><code>locals</code>, an object whose properties define local variables for the view.
                        <br>视图的局部变量 </li>
                    <li><code>callback</code>, a callback function. If provided, the method returns both the possible error and rendered string, but does not perform an automated response. When an error occurs, the method invokes <code>next(err)</code> internally.
                        <br>回调函数
                    </li>
                </ul>
                <div class="doc-box doc-notice">
                    <p>The local variable <code>cache</code> enables view caching. Set it to <code>true</code>, to cache the view during development; view caching is enabled in production by default.
                        <br>本地变量可被视图缓存，可以设置为真，使得在开发时可以缓存视图，视图缓存在开发环境中默认开启
                    </p>
                </div>
                <pre><code class="language-js">// send the rendered view to the client
res.render('index');

// if a callback is specified, the rendered HTML string has to be sent explicitly
res.render('index', function(err, html) {
  res.send(html);
});

// pass a local variable to the view
res.render('user', { name: 'Tobi' }, function(err, html) {
  // ...
});
</code></pre>
            </section>
            <section>
                <h3 id="res.send">res.send([body])</h3>
                <p>Sends the HTTP response.</p>
                <p>发送http响应</p>
                <p>The <code>body</code> parameter can be a <code>Buffer</code> object, a <code>String</code>, an object, or an <code>Array</code>. For example:</p>
                <p> 发送的可以是一个buffer对象，一个字符串，一个对象,或者一个数组。</p>
                <pre><code class="language-js">res.send(new Buffer('whoop'));
res.send({ some: 'json' });
res.send('&lt;p&gt;some html&lt;/p&gt;');
res.status(404).send('Sorry, we cannot find that!');
res.status(500).send({ error: 'something blew up' });
</code></pre>
                <p>This method performs many useful tasks for simple non-streaming responses: For example, it automatically assigns the <code>Content-Length</code> HTTP response header field (unless previously defined) and provides automatic HEAD and HTTP cache freshness support.</p>
                <p>这个方法对一些简单的非流响应很有用，比如，它会自动给响应头加上 Content-Length属性。（除非特别指定），以及自动的头部和http缓存新鲜度支持</p>
                <p>When the parameter is a <code>Buffer</code> object, the method sets the <code>Content-Type</code> response header field to “application/octet-stream”, unless previously defined as shown below:</p>
                <p>当参数是buffer对象，这个方法会设置响应头部为“application/octet-stream”，除非之前定义了'Content-Type'类型</p>
                <pre><code class="language-js">res.set('Content-Type', 'text/html');
res.send(new Buffer('&lt;p&gt;some html&lt;/p&gt;'));
</code></pre>
                <p>When the parameter is a <code>String</code>, the method sets the <code>Content-Type</code> to “text/html”:</p>
                <p>当参数是字符串是，方法会设置 Content-Type为“text/html”</p>
                <pre><code class="language-js">res.send('&lt;p&gt;some html&lt;/p&gt;');
</code></pre>
                <p>When the parameter is an <code>Array</code> or <code>Object</code>, Express responds with the JSON representation:</p>
                <p>当参数是数组或者对象时，express会响应json对象</p>
                <pre><code class="language-js">res.send({ user: 'tobi' });
res.send([1,2,3]);
</code></pre>
            </section>
            <section>
                <h3 id="res.sendFile">res.sendFile(path [, options] [, fn])</h3>
                <div class="doc-box doc-info">
                    <p><code>res.sendFile()</code> is supported from Express v4.8.0 onwards</p>
                    <p>支持express4.8以上版本</p>
                </div>
                <p>Transfers the file at the given <code>path</code>. Sets the <code>Content-Type</code> response HTTP header field based on the filename’s extension. Unless the <code>root</code> option is set in the options object, <code>path</code> must be an absolute path of the file.</p>
                <p>传输给定路径的文件，基于文件扩展名来设置Content-Type响应头信息，除非路径在选项中被设置了，否则路径必须是绝对路径</p>
                <p>The details of the <code>options</code> object is listed in the following table.</p>
                <p>下面是详细的选项设置信息</p>
                <div class="table-scroller">
                    <table>
                        <thead>
                            <tr>
                                <th>Property</th>
                                <th>Description</th>
                                <th>Default</th>
                                <th>Availability</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>maxAge</code></td>
                                <td>Sets the max-age property of the <code>Cache-Control</code> header in milliseconds or a string in <a href="https://www.npmjs.org/package/ms">ms format</a></td>
                                <td>0</td>
                                <td> </td>
                            </tr>
                            <tr>
                                <td><code>root</code></td>
                                <td>Root directory for relative filenames.</td>
                                <td> </td>
                                <td> </td>
                            </tr>
                            <tr>
                                <td><code>lastModified</code></td>
                                <td>Sets the <code>Last-Modified</code> header to the last modified date of the file on the OS. Set <code>false</code> to disable it.</td>
                                <td>Enabled</td>
                                <td>4.9.0+</td>
                            </tr>
                            <tr>
                                <td><code>headers</code></td>
                                <td>Object containing HTTP headers to serve with the file.</td>
                                <td> </td>
                                <td> </td>
                            </tr>
                            <tr>
                                <td><code>dotfiles</code></td>
                                <td>Option for serving dotfiles. Possible values are “allow”, “deny”, “ignore”.</td>
                                <td>“ignore”</td>
                                <td> </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>The method invokes the callback function <code>fn(err)</code> when the transfer is complete or when an error occurs. If the callback function is specified and an error occurs, the callback function must explicitly handle the response process either by ending the request-response cycle, or by passing control to the next route.</p>
                <p>这个方法会在当传输完成或者发生了错误时调用你填入的回调函数，如果指定了回调函数并且发生了错误，回调函数必须处理响应进程，要么结束请求-响应 周期，要么把控制权给下一个路由</p>
                <p>Here is an example of using <code>res.sendFile</code> with all its arguments.</p>
                <pre><code class="language-js">app.get('/file/:name', function (req, res, next) {

  var options = {
    root: __dirname + '/public/',
    dotfiles: 'deny',
    headers: {
        'x-timestamp': Date.now(),
        'x-sent': true
    }
  };

  var fileName = req.params.name;
  res.sendFile(fileName, options, function (err) {
    if (err) {
      console.log(err);
      res.status(err.status).end();
    }
    else {
      console.log('Sent:', fileName);
    }
  });

})
</code></pre>
                <p><code>res.sendFile</code> provides fine-grained support for file serving as illustrated in the following example:</p>
                <p><code>res.sendFile</code>支持如下例子的文件服务</p>
                <pre><code class="language-js">app.get('/user/:uid/photos/:file', function(req, res){
  var uid = req.params.uid
    , file = req.params.file;

  req.user.mayViewFilesFrom(uid, function(yes){
    if (yes) {
      res.sendFile('/uploads/' + uid + '/' + file);
    } else {
      res.status(403).send('Sorry! you cant see that.');
    }
  });
});
</code></pre>
                <p>更多信息请查看<a href="https://github.com/pillarjs/send">send</a>.</p>
            </section>
            <section>
                <h3 id="res.sendStatus">res.sendStatus(statusCode)</h3>
                <p>Set the response HTTP status code to <code>statusCode</code> and send its string representation as the response body.</p>
                <p>发送http响应码并且发送代表它的字符串描述作为响应体</p>
                <pre><code class="language-js">res.sendStatus(200); // 等价于 res.status(200).send('OK')
res.sendStatus(403); // 等价于 res.status(403).send('Forbidden')
res.sendStatus(404); // 等价于 res.status(404).send('Not Found')
res.sendStatus(500); // 等价于 res.status(500).send('Internal Server Error')
</code></pre>
                <p>If an unsupported status code is specified, the HTTP status is still set to <code>statusCode</code> and the string version of the code is sent as the response body.</p>
                <p>如果指定了一个不支持的http状态码，那么就会把这个状态码转为字符串作为响应体发送</p>
                <pre><code class="language-js">res.sendStatus(2000); // equivalent to res.status(2000).send('2000')
</code></pre>
                <p><a href="http://en.wikipedia.org/wiki/List_of_HTTP_status_codes">More about HTTP Status Codes</a></p>
            </section>
            <section>
                <h3 id="res.set">res.set(field [, value])</h3>
                <p>Sets the response’s HTTP header <code>field</code> to <code>value</code>. To set multiple fields at once, pass an object as the parameter.</p>
                <p>设置响应头字段的值，为了一次设置多个字段，可以传一个对象作为参数</p>
                <pre><code class="language-js">res.set('Content-Type', 'text/plain');

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  'ETag': '12345'
})
</code></pre>
                <p>等同于 <code>res.header(field [, value])</code>.</p>
            </section>
            <section>
                <h3 id="res.status">res.status(code)</h3>
                <p>Use this method to set the HTTP status for the response. It is a chainable alias of Node’s <a href="http://nodejs.org/api/http.html#http_response_statuscode">response.statusCode</a>.</p>
                <p>使用这个方法设置http响应的状态码，它是<a href="http://nodejs.org/api/http.html#http_response_statuscode">response.statusCode</a>的连贯别称</p>
                <pre><code class="language-js">res.status(403).end();
res.status(400).send('Bad Request');
res.status(404).sendFile('/absolute/path/to/404.png');
</code></pre>
            </section>
            <section>
                <h3 id="res.type">res.type(type)</h3>
                <p>Sets the <code>Content-Type</code> HTTP header to the MIME type as determined by
                    <a href="https://github.com/broofa/node-mime#mimelookuppath">mime.lookup()</a> for the specified <code>type</code>. If <code>type</code> contains the “/” character, then it sets the <code>Content-Type</code> to <code>type</code>.</p>
                <p>使用mime.lookup()查询并设置 Content-Type的MIME类型 ，如果类型中包含“/”,那就不需要查询直接设置
                </p>
                <pre><code class="language-js">res.type('.html');              // =&gt; 'text/html'
res.type('html');               // =&gt; 'text/html'
res.type('json');               // =&gt; 'application/json'
res.type('application/json');   // =&gt; 'application/json'
res.type('png');                // =&gt; image/png:
</code></pre>
            </section>
            <section>
                <h3 id="res.vary">res.vary(field)</h3>
                <p>Adds the field to the <code>Vary</code> response header, if it is not there already.</p>
                <p>如果头部字段不存在，则添加这个字段作为一个可变的响应头</p>
                <pre><code class="language-js">res.vary('User-Agent').render('docs');
</code></pre>
            </section>
            <p>
                <a id="router" class="h2"></a>
            </p>
            <h2>Router</h2>
            <section>
                <p>A <code>router</code> object is an isolated instance of middleware and routes. You can think of it as a “mini-application,” capable only of performing middleware and routing functions. Every Express application has a built-in app router.</p>
                <p>路由对象是一个独立的路由中间件实例，你可以把它当做一个迷你应用，只专精于路由功能.每一个express应用都有一个內建路由</p>
                <p>A router behaves like middleware itself, so you can use it as an argument to
                    <a href="#app.use">app.use()</a> or as the argument to another router’s <a href="#router.use">use()</a> method.</p>
                <p>路由表现的像一个中间件，所以你可以把它当一个参数用到app.use()或者作为参数放到另一个路由的use()方法里</p>
                <p>The top-level <code>express</code> object has a <code>Router()</code> function that creates a new <code>router</code> object.</p>
                <p>全局的express对象里有一个 Router()函数可以用来创建一个新的路由对象</p>
                <h3 id="router">Router([options])</h3>
                <p>像下面这样创建路由实例:</p>
                <pre><code class="language-js">var router = express.Router([options]);
</code></pre>
                <p>The optional <code>options</code> parameter specifies the behavior of the router.</p>
                <p>选项的参数设置决定了路由的行为表现</p>
                <div class="table-scroller">
                    <table>
                        <thead>
                            <tr>
                                <th>Property</th>
                                <th>Description</th>
                                <th>Default</th>
                                <th>Availability</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><code>caseSensitive</code></td>
                                <td>Enable case sensitivity.</td>
                                <td>Disabled by default, treating “/Foo” and “/foo” as the same.</td>
                                <td> </td>
                            </tr>
                            <tr>
                                <td><code>mergeParams</code></td>
                                <td>Preserve the <code>req.params</code> values from the parent router. If the parent and the child have conflicting param names, the child’s value take precedence.</td>
                                <td><code>false</code></td>
                                <td>4.5.0+</td>
                            </tr>
                            <tr>
                                <td><code>strict</code></td>
                                <td>Enable strict routing.</td>
                                <td>Disabled by default, “/foo” and “/foo/” are treated the same by the router.</td>
                                <td> </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>You can add middleware and HTTP method routes (such as <code>get</code>, <code>put</code>, <code>post</code>, and so on) to <code>router</code> just like an application.</p>
                <p>你可以像一个完整应用一样使用中间件和各种http方法来处理不同路径的请求</p>
                <pre><code class="language-js">// invoked for any requests passed to this router
router.use(function(req, res, next) {
  // .. some logic here .. like any other middleware
  next();
});

// will handle any request that ends in /events
// depends on where the router is "use()'d"
router.get('/events', function(req, res, next) {
  // ..
});
</code></pre>
                <p>You can then use a router for a particular root URL in this way separating your routes into files or even mini-apps.</p>
                <p>你可以对根目录的指定路径使用特定的路由</p>
                <pre><code class="language-js">// only requests to /calendar/* will be sent to our "router"
app.use('/calendar', router);
</code></pre>
            </section>
            <h3 id="router.methods">Methods</h3>
            <section>
                <h3 id="router.all">router.all(path, [callback, ...] callback)</h3>
                <p>This method functions just like the <code>router.METHOD()</code> methods, except that it matches all HTTP verbs.</p>
                <p>这个方法像一个方法集合router.METHOD() ,但他能匹配所有的HTTP请求</p>
                <p>This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches. For example, if you placed the following route at the top of all other route definitions, it would require that all routes from that point on would require authentication, and automatically load a user. Keep in mind that these callbacks do not have to act as end points; <code>loadUser</code> can perform a task, then call <code>next()</code> to continue matching subsequent routes.
                </p>
                <p>它对实现特定前缀的路径或者所有路径匹配一个全局规则很有帮助. 比如，你下面的代码放在其他路由定义前面, 它就会要求所有路由需要一个身份验证, 并且自动初始化一个用户.注意:这些回调函数不会表现得像请求-响应模式一样 loadUser 能自己开启一个任务, 然后使用 next() 自己匹配下面的路由规则.
                </p>
                <pre><code class="language-js">router.all('*', requireAuthentication, loadUser);
</code></pre>
                <p>Or the equivalent:</p>
                <p>或者等价于</p>
                <pre><code class="language-js">router.all('*', requireAuthentication)
router.all('*', loadUser);
</code></pre>
                <p>Another example of this is white-listed “global” functionality. Here the example is much like before, but it only restricts paths prefixed with “/api”:
                </p>
                <p>另一个例子是给全局添加到白名单. 只是严格匹配了'/api'路径 :</p>
                <pre><code class="language-js">router.all('/api/*', requireAuthentication);
</code></pre>
            </section>
            <section>
                <h3 id="router.METHOD">router.METHOD(path, [callback, ...] callback)</h3>
                <p>The <code>router.METHOD()</code> methods provide the routing functionality in Express, where METHOD is one of the HTTP methods, such as GET, PUT, POST, and so on, in lowercase. Thus, the actual methods are <code>router.get()</code>, <code>router.post()</code>,
                    <code>router.put()</code>, and so on.</p>
                <p>router.METHOD()提供了express里的各种路由功能，METHOD可以是http请求方法的一种，GET, PUT, POST。。。方法名为小写，因此实际的方法是router.get(), router.post(), router.put()...
                </p>
                <p>You can provide multiple callbacks, and all are treated equally, and behave just like middleware, except that these callbacks may invoke <code>next('route')</code> to bypass the remaining route callback(s). You can use this mechanism to perform pre-conditions on a route then pass control to subsequent routes when there is no reason to proceed with the route matched.</p>
                <p>你能像中间层一样提供多个回调函数, 除了那些 能被剩余路由影响的回调 next('route') . 你能通过这样给路由设置前置条件, 如果当前路由逻辑结束就可以交给下级路由
                </p>
                <p>The following snippet illustrates the most simple route definition possible. Express translates the path strings to regular expressions, used internally to match incoming requests. Query strings are <em>not</em> considered when performing these matches, for example “GET /” would match the following route, as would “GET /?name=tobi”.</p>
                <p>下面的示例是最简单的路由定义了，express的把字符串路径转换成正则表达式，用它来匹配各种路径的请求，查询字符串则会被忽略在匹配规则里，比如“GET /”会和“GET /?name=tobi”命中同一个路由</p>
                <pre><code class="language-js">router.get('/', function(req, res){
  res.send('hello world');
});
</code></pre>
                <p>You can also use regular expressions—useful if you have very specific constraints, for example the following would match “GET /commits/71dbb9c” as well as “GET /commits/71dbb9c..4c084f9”.</p>
                <p>如果你有特殊的需要，你也可以使用完全的正则表达式，比如下面这例子就会匹配“GET /commits/71dbb9c”和“GET /commits/71dbb9c..4c084f9”</p>
                <pre><code class="language-js">router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});
</code></pre>
            </section>
            <section>
                <h3 id="router.param">router.param([name,] callback)</h3>
                <p>Add callback triggers to route parameters, where <code>name</code> is the name of the parameter or an array of them, and <code>function</code> is the callback function. The parameters of the callback function are the request object, the response object, the next middleware, and the value of the parameter, in that order.</p>
                <p>对路由路径参数添加回调，name是参数的名字或者参数数组，function是回调函数，回调函数的参数有 req，res，next(),和路径参数的值。</p>
                <p>If <code>name</code> is an array, the <code>callback</code> trigger is registered for each parameter declared in it, in the order in which they are declared. Furthermore, for each declared parameter except the last one, a call to <code>next</code> inside the callback will call the callback for the next declared parameter. For the last parameter, a call to <code>next</code> will call the next middleware in place for the route currently being processed, just like it would if <code>name</code> were just a string.</p>
                <p> 如果name是数组，回调函数会对数组中的每一个声明的参数都生效，此外对除了最后一个的参数，next（）会调用下一个参数的回调
                </p>
                <p>For example, when <code>:user</code> is present in a route path, you may map user loading logic to automatically provide <code>req.user</code> to the route, or perform validations on the parameter input.</p>
                <p>例如,:user是当前路由的路径，你能加载一个逻辑自动提供req.user给路由,或者用校验函数来检测参数
                </p>
                <pre><code class="language-js">router.param('user', function(req, res, next, id) {

  // try to get the user details from the User model and attach it to the request object
  User.find(id, function(err, user) {
    if (err) {
      next(err);
    } else if (user) {
      req.user = user;
      next();
    } else {
      next(new Error('failed to load user'));
    }
  });
});
</code></pre>
                <p>Param callback functions are local to the router on which they are defined. They are not inherited by mounted apps or routers. Hence, param callbacks defined on <code>router</code> will be triggered only by route parameters defined on <code>router</code> routes.</p>
                <p>参数回调会在被定义的地方局部注册，他们不会被挂载的主节点或者路由继承，因此Param回调只会被在被定义的路由下继承</p>
                <p>A param callback will be called only once in a request-response cycle, even if the parameter is matched in multiple routes, as shown in the following examples.</p>
                <p>所有的参数回调会优先调用，而且在请求响应周期内只会调用一次，即使请求路径拥有多个回调.</p>
                <pre><code class="language-js">router.param('id', function (req, res, next, id) {
  console.log('CALLED ONLY ONCE');
  next();
})

app.get('/user/:id', function (req, res, next) {
  console.log('although this matches');
  next();
});

app.get('/user/:id', function (req, res) {
  console.log('and this matches too');
  res.end();
});
</code></pre>
                <p>On <code>GET /user/42</code>, the following is printed:</p>
                <pre><code>CALLED ONLY ONCE
although this matches
and this matches too
</code></pre>
                <pre><code class="language-js">router.param(['id', 'page'], function (req, res, next, value) {
  console.log('CALLED ONLY ONCE with', value);
  next();
})

app.get('/user/:id/:page', function (req, res, next) {
  console.log('although this matches');
  next();
});

app.get('/user/:id/:page', function (req, res) {
  console.log('and this matches too');
  res.end();
});
</code></pre>
                <p>On <code>GET /user/42/3</code>, the following is printed:</p>
                <pre><code>CALLED ONLY ONCE with 42
CALLED ONLY ONCE with 3
although this matches
and this matches too
</code></pre>
                <div class="doc-box doc-warn">
                    <p>The following section describes <code>router.param(callback)</code>, which is deprecated as of v4.11.0.下面的描述不建议使用</p>
                </div>
                <p>The behavior of the <code>router.param(name, callback)</code> method can be altered entirely by passing only a function to <code>router.param()</code>. This function is a custom implementation of how <code>router.param(name, callback)</code> should behave - it accepts two parameters and must return a middleware.</p>
                <p>app.param方法也能只传一个参数.这样并不像app.param(name, callback)传两个参数返回一个中间层一样直观。</p>
                <p>The first parameter of this function is the name of the URL parameter that should be captured, the second parameter can be any JavaScript object which might be used for returning the middleware implementation.</p>
                <p>回调的第一个参数是param名.第二个参数可以是任何JavaScript对象</p>
                <p>The middleware returned by the function decides the behavior of what happens when a URL parameter is captured.</p>
                <p>这个回调函数返回的中间层会决定URL地址被捕获到时的行为.</p>
                <p>In this example, the <code>router.param(name, callback)</code> signature is modified to <code>router.param(name, accessId)</code>. Instead of accepting a name and a callback, <code>router.param()</code> will now accept a name and a number.</p>
                <p>这个例子中，app.param(name, callback)被修饰成app.param(name, accessId)，而不是接受name和回调，现在app.param()将接受一个name和数字作为参数</p>
                <pre><code class="language-js">var express = require('express');
var app = express();
var router = express.Router();

// customizing the behavior of router.param()
router.param(function(param, option) {
  return function (req, res, next, val) {
    if (val == option) {
      next();
    }
    else {
      res.sendStatus(403);
    }
  }
});

// using the customized router.param()
router.param('id', 1337);

// route to trigger the capture
router.get('/user/:id', function (req, res) {
  res.send('OK');
})

app.use(router);

app.listen(3000, function () {
  console.log('Ready');
})
</code></pre>
                <p>In this example, the <code>router.param(name, callback)</code> signature remains the same, but instead of a middleware callback, a custom data type checking function has been defined to validate the data type of the user id.</p>
                <p>在这个例子中，app.param(name, callback)得到保留，但是callback被替换成一个中间件，一个校验函数被用来检测user的id.</p>
                <pre><code class="language-js">router.param(function(param, validator) {
  return function (req, res, next, val) {
    if (validator(val)) {
      next();
    }
    else {
      res.sendStatus(403);
    }
  }
})

router.param('id', function (candidate) {
  return !isNaN(parseFloat(candidate)) &amp;&amp; isFinite(candidate);
});
</code></pre>
            </section>
            <section>
                <h3 id="router.route">router.route(path)</h3>
                <p>Returns an instance of a single route which you can then use to handle HTTP verbs with optional middleware. Use <code>router.route()</code> to avoid duplicate route naming and thus typo errors.</p>
                <p>返回一个路由的实例，你能用可选的中间件来处理http请求，使用app.route()来避免重复多次路由名称.</p>
                <p>Building on the <code>router.param()</code> example above, the following code shows how to use
                    <code>router.route()</code> to specify various HTTP method handlers.</p>
                <p>基于上面的示例，下面的代码会展示如何使用 router.route()来处理不同类型的http请求</p>
                <pre><code class="language-js">var router = express.Router();

router.param('user_id', function(req, res, next, id) {
  // sample user, would actually fetch from DB, etc...
  req.user = {
    id: id,
    name: 'TJ'
  };
  next();
});

router.route('/users/:user_id')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
  next();
})
.get(function(req, res, next) {
  res.json(req.user);
})
.put(function(req, res, next) {
  // just an example of maybe updating the user
  req.user.name = req.params.name;
  // save user ... etc
  res.json(req.user);
})
.post(function(req, res, next) {
  next(new Error('not implemented'));
})
.delete(function(req, res, next) {
  next(new Error('not implemented'));
})
</code></pre>
                <p>This approach re-uses the single ‘/users/:user_id’ path and add handlers for various HTTP methods.</p>
                <p>这样我们就能多次使用‘/users/:user_id’单个路径来处理不同的http请求啦</p>
            </section>
            <section>
                <h3 id="router.use">router.use([path], [function, ...] function)</h3>
                <p>Uses the given middleware <code>function</code>, with optional mount path <code>path</code>, that defaults to “/”.</p>
                <p>使用给定的中间件函数，挂载在可选项的路径上，默认是'/'</p>
                <p>This method is similar to <a href="#app.use">app.use()</a>. A simple example and usecase is described below. See <a href="#app.use">app.use()</a> for more information.</p>
                <p>方法和<a href="#app.use">app.use()</a>类似，查看下面的简单示例和描述</p>
                <p>Middleware is like a plumbing pipe, requests start at the first middleware you define and work their way “down” the middleware stack processing for each path they match.</p>
                <p>中间件像一个水管管道，请求从你最开始定义的中间件开始向每一个匹配到的路径'流动'。</p>
                <pre><code class="language-js">var express = require('express');
var app = express();
var router = express.Router();

// simple logger for this router's requests
// all requests to this router will first hit this middleware
router.use(function(req, res, next) {
  console.log('%s %s %s', req.method, req.url, req.path);
  next();
});

// this will only be invoked if the path starts with /bar from the mount point
router.use('/bar', function(req, res, next) {
  // ... maybe some additional /bar logging ...
  next();
});

// always invoked
router.use(function(req, res, next) {
  res.send('Hello World');
});

app.use('/foo', router);

app.listen(3000);
</code></pre>
                <p>The “mount” path is stripped and is <em>not</em> visible to the middleware <code>function</code>. The main effect of this feature is that mounted middleware may operate without code changes regardless of its “prefix” pathname.</p>
                <p>挂载的路径是剥离的并且无法对中间件函数可见，这个特性的主要作用就是被挂载的中间件可以使用而不用在意它前置的路径名</p>
                <p>The order in which you define middleware with <code>router.use()</code> is very important. They are invoked sequentially, thus the order defines middleware precedence. For example, usually a logger is the very first middleware you would use, so every request is logged.</p>
                <p>你用router.use()定义中间件的顺序也十分重要，他们会被按顺序调用，因此有些中间件需要优先调用，例如，logger需要最先被调用以便于记录每一个请求</p>
                <pre><code class="language-js">var logger = require('morgan');

router.use(logger());
router.use(express.static(__dirname + '/public'));
router.use(function(req, res){
  res.send('Hello');
});
</code></pre>
                <p>Now suppose you wanted to ignore logging requests for static files, but to continue logging routes and middleware defined after <code>logger()</code>. You would simply move <code>static()</code> above:</p>
                <p>现在，假设你需要忽略静态资源的请求，但是想记录路由的日志信息，你可以只需要把静态资源中间件提前</p>
                <pre><code class="language-js">router.use(express.static(__dirname + '/public'));
router.use(logger());
router.use(function(req, res){
  res.send('Hello');
});
</code></pre>
                <p>Another concrete example is serving files from multiple directories, giving precedence to “./public” over the others:</p>
                <p>另一个示例是关于多文件夹静态资源目录，请把“./public”放在其他文件夹之前</p>
                <pre><code class="language-js">app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads'));
</code></pre>
                <p>The <code>router.use()</code> method also supports named parameters so that your mount points for other routers can benefit from preloading using named parameters.</p>
                <p>router.use()也支持命名的参数以便于你的其他的路由能够从中受益。</p>
            </section>
        </div>
    </section>
    <a id="top" href="#"><img src="picture/arrow.png"></a>
    <footer>
        <div id="footer-content">
            <div id="github">
                <a href="https://github.com/strongloop/express" target="_blank">Github Repo</a>
            </div>
            <div id="sponsor">Express 项目由 <a href="http://strongloop.com/" target="_blank">StrongLoop</a> 赞助。</div>
            <div id="fork"><a href="https://github.com/strongloop/express?_ga=1.39756451.1408343404.1407943788" target="_blank">Expressjs.com 网站源码托管在 GitHub</a>。
            </div>
            <div>Copyright &copy; StrongLoop, Inc., and other expressjs.com contributors.</div>
        </div>
        <div class="friend-links">
            <a href="http://www.bootcss.com/" title="Bootstrap 中文网">Bootstrap中文网</a>
            <a href="http://www.gruntjs.net/" title="Grunt 中文网">Grunt中文网</a>
            <a href="http://www.gulpjs.com.cn/" title="Gulp 中文网">Gulp中文网</a>
            <a href="http://www.bootcdn.cn/" title="BootCDN 加速">BootCDN</a>
            <a href="http://www.nodeapp.cn/" title="Node.js 中文文档">Node.js 中文文档</a>
        </div>
    </footer>
    <div class="beian">
        <a href="http://www.miibeian.gov.cn/" target="_blank">冀ICP备15008021号</a><span>|</span>© Express 中文网 2015
    </div>
</body>

</html>
